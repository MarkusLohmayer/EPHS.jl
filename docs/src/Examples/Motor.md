# DC shunt motor

```@setup 1
using EPHS
```

A DC motor has a fixed outer part, called stator, and a rotating inner part, called rotor. Both parts contain a coil of wire through which current flows. In the case of a shunt motor, these two inductors are connected in parallel to a source of electric energy.

First,
we model the stator
and then the rotor.
Finally,
we combine them into the motor model.


## Stator

First and foremost,
the stator has a coil,
which generates a magnetic field.
The following storage component models its inductance:

```@example 1
coil = let
  I = Dtry(
    :b => Dtry(magnetic_flux)
  )
  b = XVar(:b)
  l = Par(:l, 1.) # inductance
  E = Const(0.5) * b^Const(2) / l
  StorageComponent(I, E)
end;
nothing # hide
```

To connect the coil,
which stores magnetic energy,
to a source of electric energy,
we need to model
the reversible coupling
between the electric and the magnetic energy domain:

```@example 1
emc = ReversibleComponent(
  Dtry(
    :q => Dtry(ReversiblePort(FlowPort(charge, EVar(:b)))),
    :b => Dtry(ReversiblePort(FlowPort(magnetic_flux, -EVar(:q))))
  )
);
nothing # hide
```

The following irreversible component
models the resistance of the coil:

```@example 1
res = let
  r = Par(:r, 0.01) # resistance coefficient
  b₊e = EVar(:b)
  s₊e = EVar(:s)
  b₊f = r * b₊e
  s₊f = -((r * b₊e * b₊e) / (θ₀ + s₊e))
  IrreversibleComponent(
    Dtry(
      :b => Dtry(IrreversiblePort(magnetic_flux, b₊f)),
      :s => Dtry(IrreversiblePort(entropy, s₊f))
    )
  )
end;
nothing # hide
```

The following component models
storage of thermal energy in the stator:

```@example 1
tc = let
  I = Dtry(
    :s => Dtry(entropy)
  )
  s = XVar(:s)
  c₁ = Par(:c₁, 1.0)
  c₂ = Par(:c₂, 2.0)
  E = c₁ * exp(s / c₂)
  StorageComponent(I, E)
end;
nothing # hide
```

Now, we can interconnect the primitive systems
into the stator model:

```@example 1
stator = CompositeSystem(
  Dtry(
    :b => Dtry(Junction(magnetic_flux, Position(2, 3), exposed=true, power=false)),
    :q => Dtry(Junction(charge, Position(2, 1), exposed=true)),
    :s => Dtry(Junction(entropy, Position(2, 5))),
  ),
  Dtry(
    :emc => Dtry(
      InnerBox(
        Dtry(
          :q => Dtry(InnerPort(■.q)),
          :b => Dtry(InnerPort(■.b)),
        ),
        emc,
        Position(2, 2)
      ),
    ),
    :coil => Dtry(
      InnerBox(
        Dtry(
          :b => Dtry(InnerPort(■.b)),
        ),
        coil,
        Position(1, 3)
      ),
    ),
    :res => Dtry(
      InnerBox(
        Dtry(
          :b => Dtry(InnerPort(■.b)),
          :s => Dtry(InnerPort(■.s))
        ),
        res,
        Position(2, 4)
      ),
    ),
    :tc => Dtry(
      InnerBox(
        Dtry(
          :s => Dtry(InnerPort(■.s))
        ),
        tc,
        Position(1, 5)
      ),
    ),
  )
)
```


## Rotor

To define the rotor model,
we can reuse the primitive subsystems of the stator model,
although the parameters probably need to be updated.

Additionally,
we need a component that models storage of kinetic energy
due to the rotors angular mass:

```@example 1
mass = let
  I = Dtry(
    :p => Dtry(angular_momentum)
  )
  p = XVar(:p)
  m = Par(:m, 1.) # angular mass
  E = Const(1/2) * p^Const(2) / m
  StorageComponent(I, E)
end;
nothing # hide
```

We also model the mechanical friction of the rotor:

```@example 1
mf = let
  d = Par(:d, 0.01)
  p₊e = EVar(:p)
  s₊e = EVar(:s)
  p₊f = d * p₊e
  s₊f = -((d * p₊e * p₊e) / (θ₀ + s₊e))
  IrreversibleComponent(
    Dtry(
      :p => Dtry(IrreversiblePort(angular_momentum, p₊f)),
      :s => Dtry(IrreversiblePort(entropy, s₊f))
    )
  )
end;
nothing # hide
```

Last but not least,
we need a reversible component that
describes the coupling of
the magnetic energy domain
and the kinetic energy domain,
which depends on the magnetic flux generated by the stator:

```@example 1
mkc = let
  bₛ₊x = XVar(:bₛ)
  b₊e = EVar(:b)
  p₊e = EVar(:p)
  b₊f = bₛ₊x * p₊e
  p₊f = -(bₛ₊x * b₊e)
  ReversibleComponent(
    Dtry(
      :b => Dtry(ReversiblePort(FlowPort(magnetic_flux, b₊f))),
      :p => Dtry(ReversiblePort(FlowPort(angular_momentum, p₊f))),
      :bₛ => Dtry(ReversiblePort(StatePort(magnetic_flux)))
    )
  )
end;
nothing # hide
```

We can now combine all primitive systems
into the rotor model:

```@example 1
rotor = CompositeSystem(
  Dtry(
    :q => Dtry(Junction(charge, Position(2, 1), exposed=true)),
    :b => Dtry(Junction(magnetic_flux, Position(2, 3))),
    :bₛ => Dtry(Junction(magnetic_flux, Position(1, 4), exposed=true, power=false)),
    :p => Dtry(Junction(angular_momentum, Position(2, 5), exposed=true)),
    :s => Dtry(Junction(entropy, Position(3, 4))),
  ),
  Dtry(
    :emc => Dtry(
      InnerBox(
        Dtry(
          :q => Dtry(InnerPort(■.q)),
          :b => Dtry(InnerPort(■.b)),
        ),
        emc,
        Position(2, 2)
      ),
    ),
    :coil => Dtry(
      InnerBox(
        Dtry(
          :b => Dtry(InnerPort(■.b)),
        ),
        coil,
        Position(1, 3)
      ),
    ),
    :mkc => Dtry(
      InnerBox(
        Dtry(
          :b => Dtry(InnerPort(■.b)),
          :p => Dtry(InnerPort(■.p)),
          :bₛ => Dtry(InnerPort(■.bₛ, power=false)),
        ),
        mkc,
        Position(2, 4)
      ),
    ),
    :mass => Dtry(
      InnerBox(
        Dtry(
          :p => Dtry(InnerPort(■.p)),
        ),
        mass,
        Position(1, 5)
      ),
    ),
    :res => Dtry(
      InnerBox(
        Dtry(
          :b => Dtry(InnerPort(■.b)),
          :s => Dtry(InnerPort(■.s))
        ),
        res,
        Position(3, 3)
      ),
    ),
    :mf => Dtry(
      InnerBox(
        Dtry(
          :p => Dtry(InnerPort(■.p)),
          :s => Dtry(InnerPort(■.s))
        ),
        mf,
        Position(3, 5)
      ),
    ),
    :tc => Dtry(
      InnerBox(
        Dtry(
          :s => Dtry(InnerPort(■.s))
        ),
        tc,
        Position(4, 4)
      ),
    ),
  )
)
```


## Motor

Now we can interconnect
the stator and rotor:

```@example 1
motor = CompositeSystem(
  Dtry(
    :q => Dtry(Junction(charge, Position(2, 1), exposed=true)),
    :bₛ => Dtry(Junction(magnetic_flux, Position(2, 2), power=false)),
    :p => Dtry(Junction(angular_momentum, Position(3, 3), exposed=true)),
  ),
  Dtry(
    :stator => Dtry(
      InnerBox(
        Dtry(
          :q => Dtry(InnerPort(■.q)),
          :b => Dtry(InnerPort(■.bₛ, power=false)),
        ),
        stator,
        Position(1, 2)
      ),
    ),
    :rotor => Dtry(
      InnerBox(
        Dtry(
          :q => Dtry(InnerPort(■.q)),
          :bₛ => Dtry(InnerPort(■.bₛ, power=false)),
          :p => Dtry(InnerPort(■.p)),
        ),
        rotor,
        Position(3, 2)
      ),
    ),
  )
)
```


## Evolution equations

As the implementation does not yet support
the simulation of open systems with 'boundary conditions',
we can merely assemble the equations:

```@example 1
assemble(motor)
```
