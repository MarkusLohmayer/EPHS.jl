# DC shunt motor

```@setup 1
using EPHS
```

A DC motor has a fixed outer part, called stator, and a rotating inner part, called rotor. Both parts contain a coil of wire through which current flows. In the case of a shunt motor, these two inductors are connected in parallel to a source of electric energy.

First,
we model the stator
and then the rotor.
Finally,
we combine them into the motor model.


## Stator

First and foremost,
the stator has a coil,
which generates a magnetic field.
We use the methods [`linear_inductor`](@ref)
and [`thermal_capacity`](@ref)
from the [`ComponentLibrary`](@ref)
to define storage components
that model its inductance and thermal capacity:

```@example 1
coil = linear_inductor(1.0)
tc = thermal_capacity(1.0, 2.0);
nothing # hide
```

To define the stator model,
we further use the reversible component [`emc`](@ref)
that models the coupling
between the electric and the magnetic energy domain,
and we use the method [`magnetic_resistor`](@ref)
to define an irreversible component
that models the resistance of the coil.

```@example 1
stator = CompositeSystem(
  Dtry(
    :b => Dtry(Junction(magnetic_flux, Position(2, 3), exposed=true, power=false)),
    :q => Dtry(Junction(charge, Position(2, 1), exposed=true)),
    :s => Dtry(Junction(entropy, Position(2, 5))),
  ),
  Dtry(
    :emc => Dtry(
      InnerBox(
        Dtry(
          :q => Dtry(InnerPort(■.q)),
          :b => Dtry(InnerPort(■.b)),
        ),
        emc,
        Position(2, 2)
      ),
    ),
    :coil => Dtry(
      InnerBox(
        Dtry(
          :b => Dtry(InnerPort(■.b)),
        ),
        coil,
        Position(1, 3)
      ),
    ),
    :res => Dtry(
      InnerBox(
        Dtry(
          :b => Dtry(InnerPort(■.b)),
          :s => Dtry(InnerPort(■.s))
        ),
        magnetic_resistor(0.01),
        Position(2, 4)
      ),
    ),
    :tc => Dtry(
      InnerBox(
        Dtry(
          :s => Dtry(InnerPort(■.s))
        ),
        tc,
        Position(1, 5)
      ),
    ),
  )
)
```


## Rotor

For simplicity, we reuse
the primitive subsystems `coil` and `tc` of the stator model,
although the parameters probably need to be updated.
Further,
we use the method [`angular_mass`](@ref) from the library
to define a component
that models storage of kinetic energy:

```@example 1
mass = angular_mass(1.0);
nothing # hide
```

As the centerpiece of the model,
we define a reversible component that
describes the coupling of
the magnetic energy domain
and the kinetic energy domain,
which depends on the magnetic flux generated by the stator:

```@example 1
mkc = let
  bₛ₊x = XVar(:bₛ)
  b₊e = EVar(:b)
  p₊e = EVar(:p)
  b₊f = bₛ₊x * p₊e
  p₊f = -(bₛ₊x * b₊e)
  ReversibleComponent(
    Dtry(
      :b => Dtry(ReversiblePort(FlowPort(magnetic_flux, b₊f))),
      :p => Dtry(ReversiblePort(FlowPort(angular_momentum, p₊f))),
      :bₛ => Dtry(ReversiblePort(StatePort(magnetic_flux)))
    )
  )
end;
nothing # hide
```

To define the rotor model,
we additionally use the library method
[`rotational_friction`](@ref)
to describe the mechanical friction of the rotor.

```@example 1
rotor = CompositeSystem(
  Dtry(
    :q => Dtry(Junction(charge, Position(2, 1), exposed=true)),
    :b => Dtry(Junction(magnetic_flux, Position(2, 3))),
    :bₛ => Dtry(Junction(magnetic_flux, Position(1, 4), exposed=true, power=false)),
    :p => Dtry(Junction(angular_momentum, Position(2, 5), exposed=true)),
    :s => Dtry(Junction(entropy, Position(3, 4))),
  ),
  Dtry(
    :emc => Dtry(
      InnerBox(
        Dtry(
          :q => Dtry(InnerPort(■.q)),
          :b => Dtry(InnerPort(■.b)),
        ),
        emc,
        Position(2, 2)
      ),
    ),
    :coil => Dtry(
      InnerBox(
        Dtry(
          :b => Dtry(InnerPort(■.b)),
        ),
        coil,
        Position(1, 3)
      ),
    ),
    :mkc => Dtry(
      InnerBox(
        Dtry(
          :b => Dtry(InnerPort(■.b)),
          :p => Dtry(InnerPort(■.p)),
          :bₛ => Dtry(InnerPort(■.bₛ, power=false)),
        ),
        mkc,
        Position(2, 4)
      ),
    ),
    :mass => Dtry(
      InnerBox(
        Dtry(
          :p => Dtry(InnerPort(■.p)),
        ),
        mass,
        Position(1, 5)
      ),
    ),
    :res => Dtry(
      InnerBox(
        Dtry(
          :b => Dtry(InnerPort(■.b)),
          :s => Dtry(InnerPort(■.s))
        ),
        magnetic_resistor(0.01),
        Position(3, 3)
      ),
    ),
    :mf => Dtry(
      InnerBox(
        Dtry(
          :p => Dtry(InnerPort(■.p)),
          :s => Dtry(InnerPort(■.s))
        ),
        rotational_friction(0.01),
        Position(3, 5)
      ),
    ),
    :tc => Dtry(
      InnerBox(
        Dtry(
          :s => Dtry(InnerPort(■.s))
        ),
        tc,
        Position(4, 4)
      ),
    ),
  )
)
```


## Motor

Now we interconnect
the stator and rotor:

```@example 1
motor = CompositeSystem(
  Dtry(
    :q => Dtry(Junction(charge, Position(2, 1), exposed=true)),
    :bₛ => Dtry(Junction(magnetic_flux, Position(2, 2), power=false)),
    :p => Dtry(Junction(angular_momentum, Position(3, 3), exposed=true)),
  ),
  Dtry(
    :stator => Dtry(
      InnerBox(
        Dtry(
          :q => Dtry(InnerPort(■.q)),
          :b => Dtry(InnerPort(■.bₛ, power=false)),
        ),
        stator,
        Position(1, 2)
      ),
    ),
    :rotor => Dtry(
      InnerBox(
        Dtry(
          :q => Dtry(InnerPort(■.q)),
          :bₛ => Dtry(InnerPort(■.bₛ, power=false)),
          :p => Dtry(InnerPort(■.p)),
        ),
        rotor,
        Position(3, 2)
      ),
    ),
  )
)
```


## Evolution equations

As the implementation does not yet support
the simulation of open systems with 'boundary conditions',
we can merely assemble the equations:

```@example 1
assemble(motor)
```
