var documenterSearchIndex = {"docs":
[{"location":"Background/EnergyBased/#Energy-based-modeling","page":"Energy-based modeling","title":"Energy-based modeling","text":"","category":"section"},{"location":"Background/EnergyBased/#Hamiltonian-systems","page":"Energy-based modeling","title":"Hamiltonian systems","text":"Hamiltonian systems provide an energy-based mathematical formalism for classical mechanics, and also electromagnetism. A Hamiltonian system is essentially defined by\n\nan energy function (\"the Hamiltonian\")\namount of energy in the system as a function of the state\nmodels constitutive behavior of energy storage in the system\nsymplectic structure\nmodels reversible energy exchange (potential energy <–> kinetic energy)\ncanonically defined on cotangent bundle, i.e. when state is given by configuration variables (\"generalized coordinates\") and corresponding momenta\nstructure guarantees conservation of energy (first law of thermodynamics)\ngeneralizations of symplectic structure\nPoisson structures allow additional invariants besides energy\npresymplectic structures allow algebraic constraints\nDirac structures allow both additional invariants and algebraic constraints\n\nInvariants, i.e. functions of the state that evolve as constants in time, are closely linked to symmetries of the system (Noether's theorem).","category":"section"},{"location":"Background/EnergyBased/#Thermodynamic-modeling","page":"Energy-based modeling","title":"Thermodynamic modeling","text":"As the most famous parts of thermodynamics, the first and second law state that the total energy is conserved, and entropy production is non-negative.\n\nIn the non-equilibrium case, thermodynamics assumes a splitting of the dynamics into a reversible and an irreversible part. This is made clear in particular by the metriplectic or GENERIC framework, where the reversible part is modeled as a Hamiltonian system, which inherently conserves energy, and the irreversible part is modeled as a (generalized) gradient system, which inherently evolves toward maximum entropy. The first and second law are then guaranteed if\n\nthe reversible dynamics conserve entropy\nthe irreversible dynamics conserve energy\n\nCompared to a mechanical/Hamiltonian system, the additional irreversible part essentially summarizes the \"subscale content\" of the model. Since the part is not \"fully resolved\", the dynamics is irreversible. Essentially, it cannot happen backwards in time, for a lack of information or precision (uncertainty, usually amplified by the \"chaotic nature of the subscale content\"). The subscale energy content is traditionally called \"internal energy\". It is a function of the (macroscopic) entropy, similar to how momentum is the extensive variable to express the kinetic energy of a mechanical system. The corresponding intensive variables are given by the differential of the respective energy function. The intensive counterpart of entropy is the absolute temperature and the intensive counterpart of momentum is the velocity.\n\nEspecially in many engineering applications, the irreversible dynamics can be modeled within the framework of Linear Irreversible Thermodynamics (LIT), which is characterized by its assumption of local thermodynamic equilibrium:\n\nsufficiently macroscopic level of description that warrants the use of local temperature as a meaningful variable\nuse of \"force-flux pairs\" to model irreversible processes (e.g. temperature difference (force) causes a heat flux)\nrelation between thermodynamic forces and fluxes has Onsager symmetry","category":"section"},{"location":"Examples/Oscillator_constraint/#Constrained-oscillator","page":"Constrained oscillator","title":"Constrained oscillator","text":"In this example, we model a mechanical oscillator with two springs connected in series:\n\n<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/osc_constraint.svg\" width=\"400\"/>\n</div>\n&nbsp;\n\nThe series connection imposes the constraint that the forces in both springs must be equal. Consequently, the overall displacement and the potential energy is distributed between the springs to satisfy this constraint.\n\nTo not reinvent the wheel, this time we use hookean_spring, point_mass, and pkc from the ComponentLibrary. Besides these components, which are defined as in the previous example, we use two_springs_series_connection, which represents the constraint that the velocities (efforts) of two springs are equal:\n\nosc_constraint = CompositeSystem(\n  Dtry(\n    :q => Dtry(Junction(displacement, Position(1, 2))),\n    :p => Dtry(Junction(momentum, Position(1, 4))),\n    :q₂ => Dtry(Junction(displacement, Position(3, 2))),\n  ),\n  Dtry(\n    :pe₁ => Dtry(\n      InnerBox(\n        Dtry(\n          :q => Dtry(InnerPort(■.q)),\n        ),\n        hookean_spring(k=2.0),\n        Position(1, 1)\n      ),\n    ),\n    :pe₂ => Dtry(\n      InnerBox(\n        Dtry(\n          :q => Dtry(InnerPort(■.q₂)),\n        ),\n        hookean_spring(k=6.0),\n        Position(3, 1)\n      ),\n    ),\n    :sc => Dtry(\n      InnerBox(\n        Dtry(\n          :q => Dtry(InnerPort(■.q)),\n          :q₂ => Dtry(InnerPort(■.q₂)),\n        ),\n        two_springs_series_connection,\n        Position(2, 2)\n      ),\n    ),\n    :pkc => Dtry(\n      InnerBox(\n        Dtry(\n          :q => Dtry(InnerPort(■.q)),\n          :p => Dtry(InnerPort(■.p))\n        ),\n        pkc,\n        Position(1, 3)\n      ),\n    ),\n    :ke => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n        ),\n        point_mass(m=1.0),\n        Position(1, 5)\n      ),\n    ),\n  )\n)\n\nThis yields the following system of equations:\n\nassemble(osc_constraint)","category":"section"},{"location":"Examples/Oscillator_constraint/#Simulation","page":"Constrained oscillator","title":"Simulation","text":"We define an initial condition, simulate the system using the midpoint rule, and plot the resulting displacements:\n\nic_constraint = Dtry(\n  :ke => Dtry(\n    :p => Dtry(3.0),\n  ),\n  :pe₁ => Dtry(\n    :q => Dtry(0.0),\n  ),\n  :pe₂ => Dtry(\n    :q => Dtry(0.0),\n  )\n)\nh = 0.1\nt = 10\nsim = simulate(osc_constraint, midpoint_rule, ic_constraint, h, t)\n\nplot_evolution(\n  sim,\n  XVar(DtryPath(:pe₁), DtryPath(:q)),\n  XVar(DtryPath(:pe₂), DtryPath(:q)),\n)\n\nCompared to the first spring, the second spring is stiffer and hence contributes less to the overall displacement.","category":"section"},{"location":"Examples/Oscillator_constraint/#Comparison-with-unconstrained-case","page":"Constrained oscillator","title":"Comparison with unconstrained case","text":"To verify the numerical solution of the differential-algebraic equation, we compare the system with the unconstrained oscillator. The following code assumes that osc and ic are defined as in the previous example.\n\ncomparison = CompositeSystem(\n  Dtry(\n    :p => Dtry(Junction(momentum, Position(1, 2))),\n  ),\n  Dtry(\n    :osc => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n        ),\n        osc,\n        Position(1, 1)\n      ),\n    ),\n    :osc_constraint => Dtry(\n      InnerBox(\n        Dtry{InnerPort}(),\n        osc_constraint,\n        Position(1, 4)\n      ),\n    ),\n  )\n)\n\nWe expect that the overall displacement agrees with the unconstrained case, since the stiffness coefficients satisfy the following relation:\n\nfrac1mathttosc_constraintpe_1k\n + \nfrac1mathttosc_constraintpe_2k\n = \nfrac1mathttoscpek\n\nic_comparison = Dtry(\n  :osc => ic,\n  :osc_constraint => ic_constraint,\n)\n\nsim = simulate(comparison, midpoint_rule, ic_comparison, h, t)\n\nmaximum(abs.(\n  evolution(\n    sim,\n    XVar(DtryPath(:osc_constraint, :pe₁), DtryPath(:q)) +\n    XVar(DtryPath(:osc_constraint, :pe₂), DtryPath(:q)) -\n    XVar(DtryPath(:osc, :pe), DtryPath(:q))\n  )\n))\n\nIndeed, the maximum error is close to the limits of machine precision.","category":"section"},{"location":"Examples/Oscillator_constraint/#EPHS.ComponentLibrary.ReversibleComponentLibrary.two_springs_series_connection-Examples-Oscillator_constraint","page":"Constrained oscillator","title":"EPHS.ComponentLibrary.ReversibleComponentLibrary.two_springs_series_connection","text":"Dirac structure for connecting two springs in series:\n\nbeginbmatrix\n  mathttqf \n  mathttq_2f \n  0\nendbmatrix\n = \nbeginbmatrix\n  0  0  +1 \n  0  0  -1 \n  -1  +1  0\nendbmatrix\n\nbeginbmatrix\n  mathttqe \n  mathttq_2e \n  lambda\nendbmatrix\n\nThe constraint variable lambda distributes the rates of change of the displacement variables mathttqf and mathttq_2f such that the forces mathttqe and mathttq_2e are equal.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/Components/#Components","page":"Components","title":"Components","text":"","category":"section"},{"location":"Reference/Components/#EPHS.Components","page":"Components","title":"EPHS.Components","text":"The Components module defines the primitive systems: StorageComponents, ReversibleComponents, and IrreversibleComponents.\n\n\n\n\n\n","category":"module"},{"location":"Reference/Components/#EPHS.Components.CVar","page":"Components","title":"EPHS.Components.CVar","text":"Constraint multiplier variable\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.Component","page":"Components","title":"EPHS.Components.Component","text":"Component is a subtype of EPHS.AbstractSystems.AbstractSystem. Concrete subtypes of Component are StorageComponent, ReversibleComponent, and IrreversibleComponent.\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.Constraint","page":"Components","title":"EPHS.Components.Constraint","text":"Constraint(residual::SymExpr)\n\nThe residual is forced to be zero by the corresponding constraint variable.\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.EffortPort","page":"Components","title":"EPHS.Components.EffortPort","text":"EffortPort(quantity::Quantity, effort::SymExpr)\n\nA EffortPort of a ReversibleComponent used to define a transformer-like coupling (in combination with a corresponding FlowPort).\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.FlowPort","page":"Components","title":"EPHS.Components.FlowPort","text":"FlowPort(quantity::Quantity, flow::SymExpr)\n\nA FlowPort of a ReversibleComponent used to define a gyrator-like coupling or a transformer-like coupling (in combination with a corresponding EffortPort).\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.IrreversibleComponent","page":"Components","title":"EPHS.Components.IrreversibleComponent","text":"IrreversibleComponent(ports::Dtry{IrreversiblePort})\n\nAn IrreversibleComponent is a primitive system representing irreversible processes.\n\nFields\n\nports: directory of IrreversiblePorts\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.IrreversiblePort","page":"Components","title":"EPHS.Components.IrreversiblePort","text":"IrreversiblePort(quantity::Quantity, flow::SymExpr)\n\nA port of an IrreversibleComponent provides the flow variable.\n\nFields\n\nquantity: EPHS.AbstractSystems.Quantity of the port\nflow: EPHS.SymbolicExpressions.SymExpr defining the flow variable\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.Par","page":"Components","title":"EPHS.Components.Par","text":"Par(box_path::DtryPath, par_path::DtryPath, value::Float64\n\nSymbolic parameter identified by box_path * par_path.\n\nFields\n\nbox_path: indicates the subsystem to which the parameter belongs\npar_path: distinguishes between different parameters of the same subsystem\nvalue: (default) value of the parameter\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.Par-Tuple{Symbol, Float64}","page":"Components","title":"EPHS.Components.Par","text":"Par(name::Symbol, value::Float64\n\nConstructs a symbolic Parameter with box_path=DtryPath() and par_path=DtryPath(name).\n\nArguments\n\nname: name of the parameter\nvalue: (default) value of the parameter\n\n\n\n\n\n","category":"method"},{"location":"Reference/Components/#EPHS.Components.ReversibleComponent","page":"Components","title":"EPHS.Components.ReversibleComponent","text":"ReversibleComponent(ports::Dtry{ReversiblePort})\n\nA ReversibleComponent is a primitive system representing reversible dynamics, transformations, or constraints.\n\nFields\n\nports: directory of ReversiblePorts\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.ReversiblePort","page":"Components","title":"EPHS.Components.ReversiblePort","text":"ReversiblePort(variant::Union{FlowPort,EffortPort,StatePort,Constraint})\n\nA 'port' of a ReversibleComponent can be a\n\nFlowPort which provides a flow variable\nEffortPort which provides an effort variable\nStatePort which consumes a state variable\nConstraint which defines a residual and a constraint variable\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.StatePort","page":"Components","title":"EPHS.Components.StatePort","text":"StatePort(quantity::Quantity)\n\nA StatePort of a ReversibleComponent needed if a gyrator/transformer-like coupling or a constraint depends on a state variable of a system which is not already connected via a FlowPort or an EffortPort.\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.StorageComponent","page":"Components","title":"EPHS.Components.StorageComponent","text":"StorageComponent(ports::Dtry{StoragePort}, energy::SymExpr)\n\nA StorageComponent is a primitive system representing energy storage.\n\nFields\n\nports: directory of StoragePorts\nenergy: EPHS.SymbolicExpressions.SymExpr defining the energy\n\nA StorageComponent should be constructed using the function StorageComponent(ports::Dtry{Quantity}, energy::SymExpr), which uses symbolic differentiation to compute the effort variables of the ports.\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.StorageComponent-Tuple{Dtry{Quantity}, SymExpr}","page":"Components","title":"EPHS.Components.StorageComponent","text":"StorageComponent(ports::Dtry{Quantity}, energy::SymExpr)\n\nA StorageComponent is a primitive system representing energy storage.\n\nArguments\n\nports: directory of Quantitys defining the interface of the component (power ports only)\nenergy: EPHS.SymbolicExpressions.SymExpr defining the energy\n\n\n\n\n\n","category":"method"},{"location":"Reference/Components/#EPHS.Components.StoragePort","page":"Components","title":"EPHS.Components.StoragePort","text":"StoragePort(quantity::Quantity, effort::SymExpr)\n\nA port of a StorageComponent provides the effort variable.\n\nFields\n\nquantity: EPHS.AbstractSystems.Quantity of the port\neffort: EPHS.SymbolicExpressions.SymExpr defining the effort variable\n\n\n\n\n\n","category":"type"},{"location":"Reference/Components/#EPHS.Components.θ₀","page":"Components","title":"EPHS.Components.θ₀","text":"Symbolic parameter, see Par, representing the exergy environment temperature with a (default) value of 300K.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/Components/#EPHS.Components.π₀","page":"Components","title":"EPHS.Components.π₀","text":"Symbolic parameter, see Par, representing the exergy environment pressuere with a (default) value of 10⁵Pa.\n\n\n\n\n\n","category":"constant"},{"location":"Examples/CPD/#Cylinder-piston-device","page":"Cylinder-piston device","title":"Cylinder-piston device","text":"In this example, we consider an isolated cylinder and a piston that divides the cylinder into two gas-filled compartments:\n\n<div style=\"text-align: center;\">\n    <img src=\"../../assets/examples/cpd.svg\" width=\"400\"/>\n</div>\n&nbsp;\n\nDue to mechanical friction during its movement, the piston heats up. Temperature differences between the piston and the gas in each compartment result in heat transfer.\n\nUsing the methods point_mass, thermal_capacity, and ideal_gas from the ComponentLibrary, we define three storage components that model the kinetic energy of the piston, the internal energy of the piston, and the internal energy of the gas in each compartment:\n\nmass = point_mass(m=0.5)\ntc = thermal_capacity(c₁=1.0, c₂=2.0)\ngas = ideal_gas(c₁=1.0, c₂=2.5, v₀=1.0, c=1.5);\nnothing # hide\n\nTo encapsulate the piston into a reusable unit, we model it as a separate composite system. To define a reversible component that models the coupling between the two hydraulic energy domains of the gas on either side of the piston and the kinetic energy domain of the piston itself, we use the method hkc from the library. Further, we use the methods linear_friction and heat_transfer to define the irreversible components.\n\npiston = CompositeSystem(\n  Dtry(\n    :v₁ => Dtry(Junction(volume, Position(1, 1), exposed=true)),\n    :v₂ => Dtry(Junction(volume, Position(1, 5), exposed=true)),\n    :s₁ => Dtry(Junction(entropy, Position(4, 1), exposed=true)),\n    :s₂ => Dtry(Junction(entropy, Position(4, 5), exposed=true)),\n    :s => Dtry(Junction(entropy, Position(4, 3))),\n    :p => Dtry(Junction(momentum, Position(2, 3))),\n  ),\n  Dtry(\n    :hkc => Dtry(\n      InnerBox(\n        Dtry(\n          :v₁ => Dtry(InnerPort(■.v₁)),\n          :v₂ => Dtry(InnerPort(■.v₂)),\n          :p => Dtry(InnerPort(■.p)),\n        ),\n        hkc(a=0.02),\n        Position(1, 3)\n      ),\n    ),\n    :mass => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n        ),\n        mass,\n        Position(2, 2)\n      ),\n    ),\n    :mf => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n          :s => Dtry(InnerPort(■.s)),\n        ),\n        linear_friction(d=0.02),\n        Position(3, 3)\n      ),\n    ),\n    :ht₁ => Dtry(\n      InnerBox(\n        Dtry(\n          :s₁ => Dtry(InnerPort(■.s₁)),\n          :s₂ => Dtry(InnerPort(■.s)),\n        ),\n        heat_transfer(h=0.01),\n        Position(4, 2)\n      ),\n    ),\n    :ht₂ => Dtry(\n      InnerBox(\n        Dtry(\n          :s₁ => Dtry(InnerPort(■.s₂)),\n          :s₂ => Dtry(InnerPort(■.s)),\n        ),\n        heat_transfer(h=0.01),\n        Position(4, 4)\n      ),\n    ),\n    :tc => Dtry(\n      InnerBox(\n        Dtry(\n          :s => Dtry(InnerPort(■.s)),\n        ),\n        tc,\n        Position(5, 3)\n      ),\n    ),\n  ),\n)\n\nWe then define the model of the cylinder-piston device:\n\ncpd = CompositeSystem(\n  Dtry(\n    :v₁ => Dtry(Junction(volume, Position(1, 2))),\n    :v₂ => Dtry(Junction(volume, Position(1, 4))),\n    :s₁ => Dtry(Junction(entropy, Position(3, 2))),\n    :s₂ => Dtry(Junction(entropy, Position(3, 4))),\n  ),\n  Dtry(\n    :gas₁ => Dtry(\n      InnerBox(\n        Dtry(\n          :v => Dtry(InnerPort(■.v₁)),\n          :s => Dtry(InnerPort(■.s₁))\n        ),\n        gas,\n        Position(2, 1)\n      ),\n    ),\n    :piston => Dtry(\n      InnerBox(\n        Dtry(\n          :v₁ => Dtry(InnerPort(■.v₁)),\n          :v₂ => Dtry(InnerPort(■.v₂)),\n          :s₁ => Dtry(InnerPort(■.s₁)),\n          :s₂ => Dtry(InnerPort(■.s₂)),\n        ),\n        piston,\n        Position(2, 3)\n      ),\n    ),\n    :gas₂ => Dtry(\n      InnerBox(\n        Dtry(\n          :v => Dtry(InnerPort(■.v₂)),\n          :s => Dtry(InnerPort(■.s₂)),\n        ),\n        gas,\n        Position(2, 5)\n      ),\n    ),\n  ),\n)","category":"section"},{"location":"Examples/CPD/#Simulation","page":"Cylinder-piston device","title":"Simulation","text":"We define an initial condition and simulate the system:\n\nic = Dtry(\n  :gas₁ => Dtry(\n    :s => Dtry(1.0),\n    :v => Dtry(0.1),\n  ),\n  :gas₂ => Dtry(\n    :s => Dtry(1.0),\n    :v => Dtry(0.9),\n  ),\n  :piston => Dtry(\n    :mass => Dtry(\n      :p => Dtry(0.0),\n    ),\n    :tc => Dtry(\n      :s => Dtry(1.0),\n    ),\n  ),\n)\n\nh = 0.1    # time step size\nt = 200.0  # duration of the simulation\nsim = simulate(cpd, midpoint_rule, ic, h, t);\nnothing # hide","category":"section"},{"location":"Examples/CPD/#Plots","page":"Cylinder-piston device","title":"Plots","text":"We plot the evolution of the total volume, and the volume of each compartment:\n\ngas₁₊v = XVar(DtryPath(:gas₁), DtryPath(:v))\ngas₂₊v = XVar(DtryPath(:gas₂), DtryPath(:v))\nplot_evolution(sim,\n  gas₁₊v,\n  gas₂₊v,\n  gas₁₊v + gas₂₊v;\n  ylims=(0, Inf)\n)\n\nWe see that the total volume is conserved.\n\nNext, we plot the evolution of the total energy, the kinetic energy of the piston, the internal energy of the piston, and the internal energy of each compartment:\n\nplot_evolution(sim,\n  \"total energy\" => total_energy(cpd),\n  \"piston.mass\" => total_energy(mass; box_path=DtryPath(:piston, :mass)),\n  \"piston.tc\" => total_energy(tc; box_path=DtryPath(:piston, :tc)),\n  \"gas₁\" => total_energy(gas; box_path=DtryPath(:gas₁)),\n  \"gas₂\" => total_energy(gas; box_path=DtryPath(:gas₂));\n  ylims=(0, Inf),\n)\n\nWe see that the total energy is conserved.\n\nFinally, we plot the evolution of the total entropy, the entropy in the piston, and the entropy in each compartment:\n\npiston₊tc₊s = XVar(DtryPath(:piston, :tc), DtryPath(:s))\ngas₁₊s = XVar(DtryPath(:gas₁), DtryPath(:s))\ngas₂₊s = XVar(DtryPath(:gas₂), DtryPath(:s))\nplot_evolution(sim,\n  \"total entropy\" => total_entropy(cpd),\n  piston₊tc₊s,\n  gas₁₊s,\n  gas₂₊s;\n  ylims=(0, Inf),\n  legend=:bottomright,\n)\n\nWe see that the total entropy grows monotonically.","category":"section"},{"location":"Examples/Overview/#Examples","page":"Overview","title":"Examples","text":"In this section we want to showcase how to use the EPHS.jl implementation to model mechanical, electromagnetic, and thermodynamic systems in a modular and hierarchical manner. Similar to why functions are used in programming, the EPHS language aims to simplify the understanding, reuse, and modification of possibly complex physical models.\n\nPages = [\n  \"Oscillator.md\",\n  \"Oscillator_constraint.md\",\n  \"CPD.md\",\n  \"Motor.md\",\n]\nDepth = 1","category":"section"},{"location":"Fundamentals/Components/#ComponentsIntro","page":"Components","title":"Components","text":"Any system is ultimately composed of primitive systems, also called components. As reflected in the EPHS.jl logo, there are three kinds of them:\n\nStorage components are primitive systems representing storage of energy. Inner boxes filled with a storage component are displayed with a blue filling.\nReversible components represent reversible couplings between energy domains, reversible transformations, or constraints.  They conserve energy, entropy, and exergy. Inner boxes filled with a reversible component are displayed with a green filling.\nIrreversible components model irreversible processes. They conserve energy, produce entropy, and destroy exergy. Inner boxes filled with an irreversible component are displayed with a red filling.\n\nIn summary, the blue boxes correspond to the state of a given system, the green boxes correspond to its reversible dynamics, and the red boxes correspond to its irreversible dynamics.\n\nTo guarantee a thermodynamically consistent reversible-irreversible splitting of the dynamics of arbitrarily interconnected composite systems, systems are defined with respect to a fixed exergy reference environment. Here, we assume that the environment contains entropy and volume. The constant, energy-conjugate, intensive variables are the reference temperature theta_0 and the reference pressure pi_0.\n\nEvery component has an interface I. We write x in mathcalX_I for the combined state variable, and (x  f  e) in mathcalP_I for the combined state, flow, and effort variables associated to all its ports.","category":"section"},{"location":"Fundamentals/Components/#Storage-components","page":"Components","title":"Storage components","text":"A storage component is defined by its interface (of power ports) I, and an energy function E colon mathcalX_I to mathbbR. Based on the reference environment, the energy function induces the corresponding exergy function H colon mathcalX_I to mathbbR.\n\nThe rate of change of each state variable is given by its corresponding flow variable:\n\nfracmathrmd xmathrmd t\n = \nf\n\nEach effort variable is given by the partial derivative of the exergy function with respect to the corresponding state variable:\n\ne\n = \nfracmathrmd Hmathrmd x\n\nConsequently, the rate of change of the stored exergy is given by the pairing of the effort and flow variables:\n\nfracmathrmd Hmathrmd t\n = \nlangle e mid f rangle\n\nAs a first example, let's define a StorageComponent representing the potential energy of a Hookean spring:\n\nusing EPHS # hide\npe = let\n  I = Dtry(                       # interface\n    :q => Dtry(displacement)\n  )\n  q = XVar(:q)                    # state variable\n  k = Par(:k, 1.5)                # parameter with default value\n  E = Const(1/2) * k * q^Const(2) # energy function\n  StorageComponent(I, E)\nend\n\nThe let block is used to contain the Julia variables I, q, k, and E within a local scope.\n\nSince E does not represent internal energy, the energy and exergy functions are equal.\n\nTo complete the picture, we consider a storage component that models the internal energy of an ideal gas contained in a compartment with variable volume:\n\ngas = let\n  I = Dtry(\n    :s => Dtry(entropy),\n    :v => Dtry(volume),\n  )\n  s = XVar(:s)\n  v = XVar(:v)\n  c = Par(:c, 3 / 2)\n  c₁ = Par(:c₁, 1.0)\n  c₂ = Par(:c₂, 2.5)\n  v₀ = Par(:v₀, 1.0)\n  E = c₁ * exp(s / c₂) * (v₀ / v)^(Const(1) / c)\n  StorageComponent(I, E)\nend\n\nSince the storage component has state variables representing entropy and volume, the induced exergy function H is defined by\n\nH(s  v)\n = \nE(s  v)  -  theta_0  s  +  pi_0 * v\n\nThe effort variables are hence given by mathttse = theta - theta_0 and mathttve = -(pi - pi_0), where theta = fracpartial Epartial s and pi = -fracpartial Epartial v.\n\nWe note that in the output above, the (Julia) constants θ₀ and π₀ are printed as ENV.θ and ENV.π, respectively.","category":"section"},{"location":"Fundamentals/Components/#Reversible-components","page":"Components","title":"Reversible components","text":"Reversible components can represent generalized gyrators, generalized transformers, and constraints. While a single component can in general combine all three aspects, here we treat them separately.\n\nReversible components conserve exergy and all extensive quantities also present in the environment, including entropy. Thus, they also conserve energy.","category":"section"},{"location":"Fundamentals/Components/#Generalized-gyrators","page":"Components","title":"Generalized gyrators","text":"The relation defining a generalized gyrator is of the following form:\n\nf\n = \nL(x)  e\n\nFor every state x, the matrix L(x) is skew-symmetric. It follows that exergetic power is conserved:\n\nlangle e mid f rangle\n = \n0\n\nTo guarantee thermodynamic consistency, L has to satisfy some extra conditions stated in the article. In particular, the extensive quantities present in the environment (entropy and volume) need to be conserved.\n\nAs an example, we consider a ReversibleComponent that models the coupling between the kinetic energy domain of a piston and the two hydraulic energy domains on its front and backside:\n\nhkc = let\n  a = Par(:a, 2e-2) # cross-sectional area of cylinder/piston\n  p₊e = EVar(:p)\n  v₁₊e = EVar(:v₁)\n  v₂₊e = EVar(:v₂)\n  p₊f = a * (v₁₊e - v₂₊e)\n  v₁₊f = -(a * p₊e)\n  v₂₊f = a * p₊e\n  ReversibleComponent(\n    Dtry(\n      :p => Dtry(ReversiblePort(FlowPort(momentum, p₊f))),\n      :v₁ => Dtry(ReversiblePort(FlowPort(volume, v₁₊f))),\n      :v₂ => Dtry(ReversiblePort(FlowPort(volume, v₂₊f))),\n    ))\nend\n\nThe above defines a skew-symmetric relation:\n\nbeginbmatrix\n  mathttpf \n  mathttv_1f \n  mathttv_2f\nendbmatrix\n = \nbeginbmatrix\n   0  a  -a \n  -a  0   0 \n   a  0   0 \nendbmatrix\n\nbeginbmatrix\n  mathttpe \n  mathttv_1e \n  mathttv_2e\nendbmatrix\n\nThe condition for conservation of volume is satisfied:\n\nbeginbmatrix\n  0 \n  0 \n  0\nendbmatrix\n = \nbeginbmatrix\n   0  a  -a \n  -a  0   0 \n   a  0   0 \nendbmatrix\n\nbeginbmatrix\n  0 \n  -pi_0 \n  -pi_0\nendbmatrix","category":"section"},{"location":"Fundamentals/Components/#Generalized-transformers","page":"Components","title":"Generalized transformers","text":"The power ports and their combined flow and effort variables are split into two parts. We write f = (f_1  f_2) and e = (e_1  e_2). The relation defining a generalized transformer is of the following form:\n\nbeginbmatrix\n  f_1 \n  e_2\nendbmatrix\n = \nbeginbmatrix\n  0  -g(x) \n  g^*(x)  0\nendbmatrix\n\nbeginbmatrix\n  e_1 \n  f_2\nendbmatrix\n\nAgain, conservation of exergy follows from skew-symmetry. Regarding thermodynamic consistency, conditions on g (in particular for conservation of entropy and volume) are stated in the article.\n\nAs an example, we consider a simple mechanical lever:\n\nlever = let\n  r = Par(:r, 2.)  # ratio (mechanical advantage of lever)\n  q₁₊e = EVar(:q₁)\n  q₂₊f = FVar(:q₂)\n  q₁₊f = -(r * q₂₊f)\n  q₂₊e = r * q₁₊e\n  ReversibleComponent(\n    Dtry(\n      :q₁ => Dtry(ReversiblePort(FlowPort(displacement, q₁₊f))),\n      :q₂ => Dtry(ReversiblePort(EffortPort(displacement, q₂₊e)))\n    )\n  )\nend\n\nThe above defines a skew-symmetric relation:\n\nbeginbmatrix\n  mathttq_1f \n  mathttq_2e\nendbmatrix\n = \nbeginbmatrix\n   0  a \n  -a  0\nendbmatrix\n\nbeginbmatrix\n  mathttq_1e \n  mathttq_2f\nendbmatrix","category":"section"},{"location":"Fundamentals/Components/#Constraints","page":"Components","title":"Constraints","text":"The relation defining a constraint is of the following form:\n\nbeginbmatrix\n  f \n  0\nendbmatrix\n = \nbeginbmatrix\n  0  C^*(x) \n  -C(x)  0\nendbmatrix\n\nbeginbmatrix\n  e \n  lambda_c\nendbmatrix\n\nHere, the constraint variable (or multiplier) lambda_c is determined by the constraint equation 0 = C(x)  e.\n\nAs an example, we consider a component that allows to combine two springs in series:\n\nssc = let\n  λ = CVar(:λ)  # constraint variable\n  ReversibleComponent(\n    Dtry(\n      :q => Dtry(ReversiblePort(FlowPort(displacement, λ))),\n      :q₂ => Dtry(ReversiblePort(FlowPort(displacement, -λ))),\n      :λ => Dtry(ReversiblePort(Constraint(-EVar(:q) + EVar(:q₂))))\n    )\n  )\nend\n\nThe above defines a skew-symmetric relation:\n\nbeginbmatrix\n  mathttqf \n  mathttq_2f \n  0\nendbmatrix\n = \nbeginbmatrix\n  0   0   1 \n  0   0  -1 \n  -1  1   0\nendbmatrix\n\nbeginbmatrix\n  mathttqe \n  mathttq_2e \n  lambda_c\nendbmatrix","category":"section"},{"location":"Fundamentals/Components/#Irreversible-components","page":"Components","title":"Irreversible components","text":"Irreversible components represent irreversible processes. They have a non-negative exergy destruction rate. They conserve energy and all extensive quantities also present in the environment, except entropy. Thus, they have a non-negative entropy production rate.\n\nThe relation defining an irreversible component is of the following form:\n\nf\n = \nfrac1theta_0  M(x e)  e\n\nHere, for every state x and every effort e, the matrix M(x  e) is symmetric, non-negative definite. The symmetry property corresponds to Onsager's reciprocal relations and non-negative definiteness implies a non-negative exergy destruction rate:\n\nlangle e mid f rangle\n geq \n0\n\nTo guarantee thermodynamic consistency, M has to satisfy some extra conditions stated in the article. In particular, energy and the extensive quantities present in the environment, except entropy, need to be conserved.\n\nAs an example, we consider an IrreversibleComponent that models mechanical friction:\n\nmf = let\n  d = Par(:d, 0.02) # friction coefficient\n  p₊e = EVar(:p)\n  s₊e = EVar(:s)\n  p₊f = d * p₊e\n  s₊f = -((d * p₊e * p₊e) / (θ₀ + s₊e))\n  IrreversibleComponent(\n    Dtry(\n      :p => Dtry(IrreversiblePort(momentum, p₊f)),\n      :s => Dtry(IrreversiblePort(entropy, s₊f)),\n    )\n  )\nend\n\nThe above defines a symmetric, non-negative definite relation:\n\nbeginbmatrix\n  mathttpf \n  mathttsf\nendbmatrix\n = \nfrac1theta_0  d \nbeginbmatrix\n  theta  upsilon  \n  - upsilon  fracupsilon^2theta\nendbmatrix\n\nbeginbmatrix\n  mathttpe \n  mathttse\nendbmatrix\n = \nbeginbmatrix\n  d  upsilon \n  -fracd  upsilon^2theta\nendbmatrix\n\nHere, upsilon = mathttpe is the velocity and theta = theta_0 + mathttse is the absolute temperature at which kinetic energy is dissipated into the thermal energy domain.\n\nThe condition for conservation of energy is satisfied:\n\nbeginbmatrix\n  0 \n  0\nendbmatrix\n = \nfrac1theta_0  d \nbeginbmatrix\n  theta  upsilon  \n  - upsilon  fracupsilon^2theta\nendbmatrix\n\nbeginbmatrix\n  upsilon \n  theta\nendbmatrix","category":"section"},{"location":"Fundamentals/Overview/#Fundamentals","page":"Overview","title":"Fundamentals","text":"In this section, we introduce the involved primitive concepts:\n\nDirectories - the monadic data structure for hierarchically-organized information\nPatterns - the syntax to compose systems\nComponents - the primitive systems","category":"section"},{"location":"Reference/AbstractSystems/#AbstractSystems","page":"AbstractSystems","title":"AbstractSystems","text":"","category":"section"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems","page":"AbstractSystems","title":"EPHS.AbstractSystems","text":"The AbstractSystems module provides a common basis for the graphical syntax defined in EPHS.Patterns and the semantics defined in EPHS.Components and EPHS.CompositeSystems. Specifically, the module defines system interfaces (see Interface), an abstract type for concrete systems (see AbstractSystem), and port variables (see PortVar).\n\n\n\n\n\n","category":"module"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.AbstractSystem","page":"AbstractSystems","title":"EPHS.AbstractSystems.AbstractSystem","text":"AbstractSystem is a supertype of EPHS.Components.Component (for primitive systems) and EPHS.CompositeSystems.CompositeSystem (for systems composed of subsystems).\n\n\n\n\n\n","category":"type"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.EVar","page":"AbstractSystems","title":"EPHS.AbstractSystems.EVar","text":"EVar(box_path::DtryPath, port_path::DtryPath)\n\nAn EVar represents an effort variable of a port. See XVar for info about the fields box_path and port_path.\n\n\n\n\n\n","category":"type"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.FVar","page":"AbstractSystems","title":"EPHS.AbstractSystems.FVar","text":"FVar(box_path::DtryPath, port_path::DtryPath)\n\nA FVar represents a flow variable of a port. See XVar for info about the fields box_path and port_path.\n\n\n\n\n\n","category":"type"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.Interface","page":"AbstractSystems","title":"EPHS.AbstractSystems.Interface","text":"The interface of a system is basically a directory (see Dtry) of ports. Hence, each port of an Interface is addressed by its name (i.e. DtryPath) and it has assigned to it a PortType.\n\n\n\n\n\n","category":"type"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.PortType","page":"AbstractSystems","title":"EPHS.AbstractSystems.PortType","text":"PortType(quantity::Quantity, power::Bool)\n\nNext to its name (i.e. DtryPath, see Interface), a port is defined by its PortType, see also Interface.\n\nFields\n\nquantity: only ports with the same Quantity can be connected\npower: false means state port, true means power port\n\nState ports only have a state variable to share information about the given quantity, e.g. the amount of magnetic flux. Power ports additionally have a flow and an effort variable whose pairing yields the power that is exchanged via the port.\n\n\n\n\n\n","category":"type"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.PortVar","page":"AbstractSystems","title":"EPHS.AbstractSystems.PortVar","text":"PortVar is a supertype for port variables. Its concrete subtypes are\n\nXVar for state variables\nFVar for flow variables\nEVar for effort variables\n\n\n\n\n\n","category":"type"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.PowerVar","page":"AbstractSystems","title":"EPHS.AbstractSystems.PowerVar","text":"PowerVar is a subtype of PortVar. Concrete subtypes of PowerVar are\n\nFVar for flow variables\nEVar for effort variables\n\n\n\n\n\n","category":"type"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.Quantity","page":"AbstractSystems","title":"EPHS.AbstractSystems.Quantity","text":"Quantity(quantity::Symbol, space::Symbol, iseven::Bool)\n\nA Quantity represents a physical quantity and is used to define a PortType.\n\nFields\n\nquantity: Symbol identifying the quantity, e.g. :momentum\nspace: Symbol identifying its state space, e.g. :ℝ\niseven: false means the quantity has odd parity w.r.t. time reversal transformation\n\n\n\n\n\n","category":"type"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.Relation","page":"AbstractSystems","title":"EPHS.AbstractSystems.Relation","text":"Relation(storage::Dtry{SymExpr}, external::Dtry{Provider})\n\nA relation that defines the semantics of a system.\n\n\n\n\n\n","category":"type"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.XVar","page":"AbstractSystems","title":"EPHS.AbstractSystems.XVar","text":"XVar(box_path::DtryPath, port_path::DtryPath)\n\nA XVar represents a state variable of a port.\n\nFields\n\nbox_path: name of the EPHS.Patterns.InnerBox or system   to which the port belongs\nport_path: name of the port itself   relative to the box or system interface\n\nHence, the full path identifying the port is box_path * port_path. Both parts are stored separately to prevent ambiguities.\n\n\n\n\n\n","category":"type"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.angular_momentum","page":"AbstractSystems","title":"EPHS.AbstractSystems.angular_momentum","text":"Quantity representing a real-valued angular momentum\n\n\n\n\n\n","category":"constant"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.charge","page":"AbstractSystems","title":"EPHS.AbstractSystems.charge","text":"Quantity representing an electric charge\n\n\n\n\n\n","category":"constant"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.displacement","page":"AbstractSystems","title":"EPHS.AbstractSystems.displacement","text":"Quantity representing a real-valued displacement\n\n\n\n\n\n","category":"constant"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.entropy","page":"AbstractSystems","title":"EPHS.AbstractSystems.entropy","text":"Quantity representing an entropy\n\n\n\n\n\n","category":"constant"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.magnetic_flux","page":"AbstractSystems","title":"EPHS.AbstractSystems.magnetic_flux","text":"Quantity representing a magnetic flux\n\n\n\n\n\n","category":"constant"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.momentum","page":"AbstractSystems","title":"EPHS.AbstractSystems.momentum","text":"Quantity representing a real-valued linear momentum\n\n\n\n\n\n","category":"constant"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.volume","page":"AbstractSystems","title":"EPHS.AbstractSystems.volume","text":"Quantity representing a volume\n\n\n\n\n\n","category":"constant"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.fillcolor-Tuple{AbstractSystem}","page":"AbstractSystems","title":"EPHS.AbstractSystems.fillcolor","text":"fillcolor(system::AbstractSystem) -> String\n\nReturns the fillcolor of an EPHS.Patterns.InnerBox, which is filled by the given system. The returned String is a HTML hex color code.\n\n\n\n\n\n","category":"method"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.interface-Tuple{AbstractSystem}","page":"AbstractSystems","title":"EPHS.AbstractSystems.interface","text":"interface(system::AbstractSystem) -> Interface\n\nReturns the Interface of the given system.\n\n\n\n\n\n","category":"method"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.relation-Tuple{AbstractSystem}","page":"AbstractSystems","title":"EPHS.AbstractSystems.relation","text":"relation(system::AbstractSystem) -> Relation\n\nReturns the Relation that defines the semantics of the system.\n\n\n\n\n\n","category":"method"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.total_energy-Tuple{AbstractSystem}","page":"AbstractSystems","title":"EPHS.AbstractSystems.total_energy","text":"total_energy(system::AbstractSystem) -> SymExr\n\nReturns a symbolic expression for the total energy of the system.\n\n\n\n\n\n","category":"method"},{"location":"Reference/AbstractSystems/#EPHS.AbstractSystems.total_entropy-Tuple{AbstractSystem}","page":"AbstractSystems","title":"EPHS.AbstractSystems.total_entropy","text":"total_entropy(system::AbstractSystem) -> SymExr\n\nReturns a symbolic expression for the total entropy of the system.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Directories","page":"Directories","title":"Directories","text":"","category":"section"},{"location":"Reference/Directories/#EPHS.Directories","page":"Directories","title":"EPHS.Directories","text":"Directories - the NonEmptyDtry and Dtry monads\n\nA nonempty directory of Ts (NonEmptyDtry{T}) is essentially a tree whose leaves hold values of type T. Each value is addressed by the path from the root node to the respective leaf, given by a list of Symbols, see DtryPath.\n\nThe monad unit sends a value of type T to a tree consisting only of a leaf holding the value.\n\nThe monad multiplication flattens a directory of directories of Ts into a directory of Ts by grafting the trees stored at the leaves directly onto their respective parent nodes.\n\nA (possibly empty) directory of Ts (Dtry{T}) is either empty or it is a nonempty directory of Ts. The Dtry monad is hence obtained by composing the NonEmptyDtry monad with the 'Maybe monad'. The composition of the monads relies on a distributive law. Since subdirectories (subtrees) of a directory cannot be empty, the distributive law filters out any empty directories at the leaves, as they cannot be grafted onto their parent nodes.\n\nThis module implements directories as an immutable data structure. Subdirectories are stored in lexicographic order to ensure that two directories with the same set of paths (namespace) and the same associated values are equal.\n\nThe implementation supports simple access of subdirectories and values, pretty-printing, iteration, mapping, filtering, merging, etc.\n\n\n\n\n\n","category":"module"},{"location":"Reference/Directories/#EPHS.Directories.AbstractDtry","page":"Directories","title":"EPHS.Directories.AbstractDtry","text":"The concrete subtypes of AbstractDtry are NonEmptyDtry and Dtry.\n\n\n\n\n\n","category":"type"},{"location":"Reference/Directories/#EPHS.Directories.Dtry","page":"Directories","title":"EPHS.Directories.Dtry","text":"A Dtry{T} is either empty or it wraps a NonEmptyDtry of Ts.\n\n\n\n\n\n","category":"type"},{"location":"Reference/Directories/#EPHS.Directories.Dtry-Tuple{T} where T","page":"Directories","title":"EPHS.Directories.Dtry","text":"Dtry(value::T) -> Dtry{T}\n\nConstruct a directory, which contains just a single value (monad unit).\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.Dtry-Union{Tuple{Vararg{Pair{Symbol, <:AbstractDtry{T}}}}, Tuple{T}} where T","page":"Directories","title":"EPHS.Directories.Dtry","text":"Dtry(pairs::Vararg{Pair{Symbol,Dtry{T}}}) -> Dtry{T}\n\nConstruct a directory of Ts from a number of pairs of names and subdirectories. Empty subdirectories are filtered out.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.Dtry-Union{Tuple{}, Tuple{T}} where T","page":"Directories","title":"EPHS.Directories.Dtry","text":"Dtry{T}()\n\nConstruct an empty directory of Ts.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.DtryAccessError","page":"Directories","title":"EPHS.Directories.DtryAccessError","text":"Abstract supertype for exceptions that may be thrown when accessing directories. Concrete subtypes are DtryBranchError (branch with a given name does not exist) and DtryLeafError (given directory is not a leaf).\n\n\n\n\n\n","category":"type"},{"location":"Reference/Directories/#EPHS.Directories.DtryBranchError","page":"Directories","title":"EPHS.Directories.DtryBranchError","text":"DtryBranchError(dtry::AbstractDtry, name::Symbol)\n\nThe given directory has no direct subdirectory with the given name.\n\n\n\n\n\n","category":"type"},{"location":"Reference/Directories/#EPHS.Directories.DtryLeafError","page":"Directories","title":"EPHS.Directories.DtryLeafError","text":"DtryLeafError(dtry::AbstractDtry)\n\nThe given directory is not a leaf holding a value.\n\n\n\n\n\n","category":"type"},{"location":"Reference/Directories/#EPHS.Directories.DtryPath","page":"Directories","title":"EPHS.Directories.DtryPath","text":"A DtryPath is a linked list of Symbols representing a path in a directory, see also ■.\n\n\n\n\n\n","category":"type"},{"location":"Reference/Directories/#EPHS.Directories.DtryPath-Tuple{Vararg{Symbol}}","page":"Directories","title":"EPHS.Directories.DtryPath","text":"DtryPath(names::Vararg{Symbol})\n\nConstruct a DtryPath from a series of names.\n\nExample\n\njulia> DtryPath(:foo, :bar) == ■.foo.bar\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.NonEmptyDtry","page":"Directories","title":"EPHS.Directories.NonEmptyDtry","text":"A NonEmptyDtry{T} either contains a single value of type T or it has at least one non-empty subdirectory of Ts.\n\n\n\n\n\n","category":"type"},{"location":"Reference/Directories/#EPHS.Directories.NonEmptyDtry-Tuple{T} where T","page":"Directories","title":"EPHS.Directories.NonEmptyDtry","text":"NonEmptyDtry(value::T) -> NonEmptyDtry{T}\n\nConstruct a non-empty directory, which contains just a single value (monad unit).\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.NonEmptyDtry-Union{Tuple{Vararg{Pair{Symbol, NonEmptyDtry{T}}}}, Tuple{T}} where T","page":"Directories","title":"EPHS.Directories.NonEmptyDtry","text":"NonEmptyDtry(pairs::Vararg{Pair{Symbol,NonEmptyDtry{T}}}) -> NonEmptyDtry{T}\n\nConstruct a non-empty directory of Ts from a number of pairs of names and non-empty subdirectories.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.■","page":"Directories","title":"EPHS.Directories.■","text":"DtryPath representing the root node of a directory. With that, ■.foo represents the path to a subdirectory named foo.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/Directories/#Base.:*-Tuple{DtryPath, DtryPath}","page":"Directories","title":"Base.:*","text":"*(p1::DtryPath, p2::DtryPath) -> DtryPath\n\nConcatenate two DtryPaths.\n\nExample\n\njulia> ■.foo * ■.bar == ■.foo.bar\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.Iterators.zip-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractDtry{T1}, AbstractDtry{T2}}} where {T1, T2}","page":"Directories","title":"Base.Iterators.zip","text":"zip(dtry1::NonEmptyDtry{T1}, dtry2::NonEmptyDtry{T2}) -> NonEmptyDtry{Tuple{T1,T2}}\nzip(dtry1::Dtry{T1}, dtry2::Dtry{T2}) -> Dtry{Tuple{T1,T2}}\n\nGiven a directory of T1s and a directory of T2s with the same tree structure, as well as a function f : T1 × T2 -> X, produce a directory of Tuple{T1,T2}s, where the value at path p is given by (dtry1[p], dtry2[p]).\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.all-Tuple{Any, Dtry}","page":"Directories","title":"Base.all","text":"all(p, dtry::Dtry{T}) -> Bool\n\nReturns true if predicate p : T -> Bool returns true for all values of the directory.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.all-Tuple{Any, NonEmptyDtry}","page":"Directories","title":"Base.all","text":"all(p, dtry::NonEmptyDtry{T}) -> Bool\n\nReturns true if predicate p : T -> Bool returns true for all values of the directory.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.collect-Union{Tuple{AbstractDtry{T}}, Tuple{T}} where T","page":"Directories","title":"Base.collect","text":"collect(dtry::AbstractDtry{T}) -> Vector{T}\n\nCollect values from a directory.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.filter-Union{Tuple{T}, Tuple{Any, AbstractDtry{T}}} where T","page":"Directories","title":"Base.filter","text":"filter(f, dtry::AbstractDtry{T}) -> Dtry{T}\n\nGiven a function f : T -> Bool and a (nonempty) directory of Ts, produce a new directory of Ts by keeping the entry at path p only if f(dtry[p]) == true.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.foreach-Tuple{Any, Dtry}","page":"Directories","title":"Base.foreach","text":"foreach(f, dtry::Dtry{T}) -> Nothing\n\nCall function f on each Pair{DtryPath,T}.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.foreach-Tuple{Any, NonEmptyDtry}","page":"Directories","title":"Base.foreach","text":"foreach(f, dtry::NonEmptyDtry{T}) -> Nothing\n\nCall function f on each Pair{DtryPath,T}.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.get-Tuple{Dtry, DtryPath, Any}","page":"Directories","title":"Base.get","text":"get(dtry::Dtry, path::DtryPath, default)\n\nIf path refers to a value within dtry, returns the value. Otherwise, returns default.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.get-Tuple{NonEmptyDtry, DtryPath, Any}","page":"Directories","title":"Base.get","text":"get(dtry::NonEmptyDtry, path::DtryPath, default)\n\nIf path refers to a value within dtry, returns the value. Otherwise, returns default.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.getindex-Tuple{Dtry, DtryPath}","page":"Directories","title":"Base.getindex","text":"getindex(dtry::Dtry{T}, path::DtryPath) -> T\n\nIf path refers to a value within dtry, returns the value. Otherwise, throws a DtryAccessError.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.getindex-Union{Tuple{Dtry{T}}, Tuple{T}} where T","page":"Directories","title":"Base.getindex","text":"getindex(dtry::Dtry{T}) -> T\n\nIf dtry isa leaf, dtry[] returns its value. Otherwise, throws a DtryLeafError\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.getindex-Union{Tuple{NonEmptyDtry{T}}, Tuple{T}} where T","page":"Directories","title":"Base.getindex","text":"getindex(dtry::NonEmptyDtry{T}) -> T\n\nIf dtry isa leaf, dtry[] returns its value. Otherwise, throws a DtryLeafError\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.getindex-Union{Tuple{T}, Tuple{NonEmptyDtry{T}, DtryPath}} where T","page":"Directories","title":"Base.getindex","text":"getindex(dtry::NonEmptyDtry{T}, path::DtryPath) -> T\n\nIf path refers to a value within dtry, returns the value. Otherwise, throws a DtryAccessError.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.isempty-Tuple{Dtry}","page":"Directories","title":"Base.isempty","text":"isempty(dtry::AbstractDtry) -> Bool\n\nReturns true if the given directory is empty.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.length-Tuple{DtryPath}","page":"Directories","title":"Base.length","text":"length(path::DtryPath) -> Int\n\nReturns the length of the DtryPath (linked list of Symbols).\n\nExample\n\njulia> length(■.foo.bar) == 2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.length-Tuple{Dtry}","page":"Directories","title":"Base.length","text":"length(dtry::Dtry) -> Int\n\nReturns the number of values (leaves) in the given directory.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.length-Tuple{NonEmptyDtry}","page":"Directories","title":"Base.length","text":"length(dtry::NonEmptyDtry) -> Int\n\nReturns the number of values (leaves) in the given directory.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.map-Union{Tuple{T}, Tuple{Any, AbstractDtry{T}}} where T","page":"Directories","title":"Base.map","text":"map(f, dtry::NonEmptyDtry{T}) -> NonEmptyDtry{X}\nmap(f, dtry::Dtry{T}) -> Dtry{X}\n\nMake a new directory of Xs with the same tree structure as dtry, where the value at path p is given by f(dtry[p])::X. The return type X of f is inferred.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.map-Union{Tuple{T}, Tuple{Any, Dtry{T}, Type}} where T","page":"Directories","title":"Base.map","text":"map(f, dtry::Dtry{T}, X::Type) -> Dtry{X}\n\nMake a new directory of Xs with the same tree structure as dtry, where the value at path p is given by f(dtry[p])::X.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.map-Union{Tuple{T}, Tuple{Any, NonEmptyDtry{T}, Type}} where T","page":"Directories","title":"Base.map","text":"map(f, dtry::NonEmptyDtry{T}, X::Type) -> NonEmptyDtry{X}\n\nMake a new nonempty directory of Xs with the same tree structure as dtry, where the value at path p is given by f(dtry[p])::X.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.mapreduce-Tuple{Any, Any, Dtry, Any}","page":"Directories","title":"Base.mapreduce","text":"mapreduce(f, op, dtry::Dtry{T}, default)\n\nTransforms each value contained in the given directory using the function f : T -> X and reduces the results using the binary operation op : X × X -> X. For an empty directory, returns default.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.mapreduce-Tuple{Any, Any, NonEmptyDtry}","page":"Directories","title":"Base.mapreduce","text":"mapreduce(f, op, dtry::NonEmptyDtry{T})\n\nTransforms each value contained in the given directory using the function f : T -> X and reduces the results using the binary operation op : X × X -> X.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#Base.merge-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractDtry","page":"Directories","title":"Base.merge","text":"merge(dtry1::NonEmptyDtry{T}, dtry2::NonEmptyDtry{T}) -> NonEmptyDtry{T}\nmerge(dtry1::Dtry{T}, dtry2::Dtry{T}) -> Dtry{T}\n\nMerge two directories, given that their namespaces are disjoint, i.e. the union of their namespaces is prefix-free.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.filtermap-Union{Tuple{T}, Tuple{Any, AbstractDtry{T}, Type}} where T","page":"Directories","title":"EPHS.Directories.filtermap","text":"filtermap(f, dtry::AbstractDtry{T}, X::Type) -> Dtry{X}\n\nMake a new directory of Xs from a (nonempty) directory of Ts based on a function f : T -> Union{Some{X},Nothing}. When f returns nothing, the respective entry is filtered out.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.filtermapwithpath-Union{Tuple{T}, Tuple{Any, AbstractDtry{T}, Type}} where T","page":"Directories","title":"EPHS.Directories.filtermapwithpath","text":"filtermapwithpath(f, dtry::AbstractDtry{T}, X::Type) -> Dtry{X}\n\nMake a new directory of Xs from a (nonempty) directory of Ts based on a function f : DtryPath × T -> Union{Some{X},Nothing}. When f returns nothing, the respective entry is filtered out.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.foreachpath-Tuple{Any, Dtry}","page":"Directories","title":"EPHS.Directories.foreachpath","text":"foreachpath(f, dtry::Dtry) -> Nothing\n\nCall function f on each path::DtryPath.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.foreachpath-Tuple{Any, NonEmptyDtry}","page":"Directories","title":"EPHS.Directories.foreachpath","text":"foreachpath(f, dtry::NonEmptyDtry) -> Nothing\n\nCall function f on each path::DtryPath.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.foreachvalue-Tuple{Any, Dtry}","page":"Directories","title":"EPHS.Directories.foreachvalue","text":"foreachvalue(f, dtry::Dtry{T}) -> Nothing\n\nCall function f on each value::T.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.foreachvalue-Tuple{Any, NonEmptyDtry}","page":"Directories","title":"EPHS.Directories.foreachvalue","text":"foreachvalue(f, dtry::NonEmptyDtry{T}) -> Nothing\n\nCall function f on each value::T.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.haspath-Tuple{Dtry, DtryPath}","page":"Directories","title":"EPHS.Directories.haspath","text":"haspath(dtry::Dtry, path::DtryPath) -> Bool\n\nReturns true if the given directory contains a leaf/value at the given path.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.haspath-Tuple{NonEmptyDtry, DtryPath}","page":"Directories","title":"EPHS.Directories.haspath","text":"haspath(dtry::NonEmptyDtry, path::DtryPath) -> Bool\n\nReturns true if the given directory contains a leaf/value at the given path.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.hasprefix-Tuple{Dtry, DtryPath}","page":"Directories","title":"EPHS.Directories.hasprefix","text":"hasprefix(dtry::Dtry, prefix::DtryPath) -> Bool\n\nReturns true if the given directory has a (complete) path (to a leaf/value), which starts with the given prefix (or incomplete path).\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.hasprefix-Tuple{NonEmptyDtry, DtryPath}","page":"Directories","title":"EPHS.Directories.hasprefix","text":"hasprefix(dtry::NonEmptyDtry, prefix::DtryPath) -> Bool\n\nReturns true if the given directory has a (complete) path (to a leaf/value), which starts with the given prefix (or incomplete path).\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.mapwithpath-Union{Tuple{T}, Tuple{Any, Dtry{T}, Type}} where T","page":"Directories","title":"EPHS.Directories.mapwithpath","text":"mapwithpath(f, dtry::Dtry{T}, X::Type) -> Dtry{X}\n\nMake a new directory of Xs with the same tree structure as dtry, where the value at path p is given by f((p, dtry[p]))::X.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.mapwithpath-Union{Tuple{T}, Tuple{Any, NonEmptyDtry{T}, Type}} where T","page":"Directories","title":"EPHS.Directories.mapwithpath","text":"mapwithpath(f, dtry::NonEmptyDtry{T}, X::Type) -> NonEmptyDtry{X}\n\nMake a new directory of Xs with the same tree structure as dtry, where the value at path p is given by f((p, dtry[p]))::X.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.print_dtry-Tuple{IO, Dtry}","page":"Directories","title":"EPHS.Directories.print_dtry","text":"print_dtry(io::IO, dtry::Dtry{T}; prefix::String, print_value=nothing)\n\nWrite a pretty-printed representation of the given directory to io. As an optional keyword argument, a function print_value(io::IO, value::T; prefix::String) can be used to pretty-print the values. Whenever the output of print_value spans more than one line, prefix is prepended to the extra lines. To print a directory of directories, let print_values=print_dtry.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.print_dtry_repr-Union{Tuple{T}, Tuple{IO, Dtry{T}}} where T","page":"Directories","title":"EPHS.Directories.print_dtry_repr","text":"print_dtry_repr(io::IO, dtry::Dtry{T})\n\nWrite a round-trippable code representation of the given directory to io.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.zipmap-Union{Tuple{T2}, Tuple{T1}, Tuple{Any, Dtry{T1}, Dtry{T2}, Type}} where {T1, T2}","page":"Directories","title":"EPHS.Directories.zipmap","text":"zipmap(f, dtry1::Dtry{T1}, dtry2::Dtry{T2}, X::Type) -> Dtry{X}\n\nGiven a directory of T1s and a directory of T2s with the same tree structure, as well as a function f : T1 × T2 -> X, produce a new directory of Xs, where the value at path p is given by f(dtry1[p], dtry2[p]).\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.zipmap-Union{Tuple{T2}, Tuple{T1}, Tuple{Any, NonEmptyDtry{T1}, NonEmptyDtry{T2}, Type}} where {T1, T2}","page":"Directories","title":"EPHS.Directories.zipmap","text":"zipmap(f, dtry1::NonEmptyDtry{T1}, dtry2::NonEmptyDtry{T2}, X::Type) -> NonEmptyDtry{X}\n\nGiven a nonempty directory of T1s and a nonempty directory of T2s with the same tree structure, as well as a function f : T1 × T2 -> X, produce a new nonempty directory of Xs, where the value at path p is given by f(dtry1[p], dtry2[p]).\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.zipmapwithpath-Union{Tuple{T2}, Tuple{T1}, Tuple{Any, Dtry{T1}, Dtry{T2}, Type}} where {T1, T2}","page":"Directories","title":"EPHS.Directories.zipmapwithpath","text":"zipmapwithpath(f, dtry1::Dtry{T1}, dtry2::Dtry{T2}, X::Type) -> Dtry{X}\n\nGiven a directory of T1s and a directory of T2s with the same tree structure, as well as a function f : DtryPath × T1 × T2 -> X, produce a new directory of Xs, where the value at path p is given by f(p, dtry1[p], dtry2[p]).\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.Directories.zipmapwithpath-Union{Tuple{T2}, Tuple{T1}, Tuple{Any, NonEmptyDtry{T1}, NonEmptyDtry{T2}, Type}} where {T1, T2}","page":"Directories","title":"EPHS.Directories.zipmapwithpath","text":"zipmapwithpath(f, dtry1::NonEmptyDtry{T1}, dtry2::NonEmptyDtry{T2}, X::Type) -> NonEmptyDtry{X}\n\nGiven a directory of T1s and a directory of T2s with the same tree structure, as well as a function f : DtryPath × T1 × T2 -> X, produce a new directory of Xs, where the value at path p is given by f(p, dtry1[p], dtry2[p]).\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.MoreBase.flatten-Union{Tuple{NonEmptyDtry{NonEmptyDtry{T}}}, Tuple{T}} where T","page":"Directories","title":"EPHS.MoreBase.flatten","text":"flatten(dtry::NonEmptyDtry{NonEmptyDtry{T}}) -> Dtry{T}\n\nFlattens a nonempty directory of nonempty directories (monad multiplication).\n\n\n\n\n\n","category":"method"},{"location":"Reference/Directories/#EPHS.MoreBase.flatten-Union{Tuple{Union{Dtry{Dtry{T}}, Dtry{NonEmptyDtry{T}}, NonEmptyDtry{Dtry{T}}}}, Tuple{T}} where T","page":"Directories","title":"EPHS.MoreBase.flatten","text":"flatten(dtry::Dtry{Dtry{T}}) -> Dtry{T}\n\nFlattens a directory of directories (monad multiplication).\n\n\n\n\n\n","category":"method"},{"location":"Examples/Motor/#DC-shunt-motor","page":"DC shunt motor","title":"DC shunt motor","text":"A DC motor has a fixed outer part, called stator, and a rotating inner part, called rotor. Both parts contain a coil of wire through which current flows. In the case of a shunt motor, these two inductors are connected in parallel to a source of electric energy.\n\nFirst, we model the stator and then the rotor. Finally, we combine them into the motor model.","category":"section"},{"location":"Examples/Motor/#Stator","page":"DC shunt motor","title":"Stator","text":"First and foremost, the stator has a coil, which generates a magnetic field. We use the methods linear_inductor and thermal_capacity from the ComponentLibrary to define storage components that model its inductance and thermal capacity:\n\ncoil = linear_inductor(l=1.0)\ntc = thermal_capacity(c₁=1.0, c₂=2.0);\nnothing # hide\n\nTo define the stator model, we further use the reversible component emc that models the coupling between the electric and the magnetic energy domain, and we use the method magnetic_resistor to define an irreversible component that models the resistance of the coil.\n\nstator = CompositeSystem(\n  Dtry(\n    :b => Dtry(Junction(magnetic_flux, Position(2, 3), exposed=true, power=false)),\n    :q => Dtry(Junction(charge, Position(2, 1), exposed=true)),\n    :s => Dtry(Junction(entropy, Position(2, 5))),\n  ),\n  Dtry(\n    :emc => Dtry(\n      InnerBox(\n        Dtry(\n          :q => Dtry(InnerPort(■.q)),\n          :b => Dtry(InnerPort(■.b)),\n        ),\n        emc,\n        Position(2, 2)\n      ),\n    ),\n    :coil => Dtry(\n      InnerBox(\n        Dtry(\n          :b => Dtry(InnerPort(■.b)),\n        ),\n        coil,\n        Position(1, 3)\n      ),\n    ),\n    :res => Dtry(\n      InnerBox(\n        Dtry(\n          :b => Dtry(InnerPort(■.b)),\n          :s => Dtry(InnerPort(■.s))\n        ),\n        magnetic_resistor(r=0.01),\n        Position(2, 4)\n      ),\n    ),\n    :tc => Dtry(\n      InnerBox(\n        Dtry(\n          :s => Dtry(InnerPort(■.s))\n        ),\n        tc,\n        Position(1, 5)\n      ),\n    ),\n  )\n)","category":"section"},{"location":"Examples/Motor/#Rotor","page":"DC shunt motor","title":"Rotor","text":"For simplicity, we reuse the primitive subsystems coil and tc of the stator model. Further, we use the method angular_mass from the library to define a component that models storage of kinetic energy:\n\nmass = angular_mass(m=1.0);\nnothing # hide\n\nAs the central coupling component of the motor model, we use the component mkc from the library:\n\nTo define the rotor model, we additionally use the library method rotational_friction to describe the mechanical friction of the rotor.\n\nrotor = CompositeSystem(\n  Dtry(\n    :q => Dtry(Junction(charge, Position(2, 1), exposed=true)),\n    :b => Dtry(Junction(magnetic_flux, Position(2, 3))),\n    :bₛ => Dtry(Junction(magnetic_flux, Position(1, 4), exposed=true, power=false)),\n    :p => Dtry(Junction(angular_momentum, Position(2, 5), exposed=true)),\n    :s => Dtry(Junction(entropy, Position(3, 4))),\n  ),\n  Dtry(\n    :emc => Dtry(\n      InnerBox(\n        Dtry(\n          :q => Dtry(InnerPort(■.q)),\n          :b => Dtry(InnerPort(■.b)),\n        ),\n        emc,\n        Position(2, 2)\n      ),\n    ),\n    :coil => Dtry(\n      InnerBox(\n        Dtry(\n          :b => Dtry(InnerPort(■.b)),\n        ),\n        coil,\n        Position(1, 3)\n      ),\n    ),\n    :mkc => Dtry(\n      InnerBox(\n        Dtry(\n          :b => Dtry(InnerPort(■.b)),\n          :p => Dtry(InnerPort(■.p)),\n          :bₛ => Dtry(InnerPort(■.bₛ, power=false)),\n        ),\n        mkc,\n        Position(2, 4)\n      ),\n    ),\n    :mass => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n        ),\n        mass,\n        Position(1, 5)\n      ),\n    ),\n    :res => Dtry(\n      InnerBox(\n        Dtry(\n          :b => Dtry(InnerPort(■.b)),\n          :s => Dtry(InnerPort(■.s))\n        ),\n        magnetic_resistor(r=0.01),\n        Position(3, 3)\n      ),\n    ),\n    :mf => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n          :s => Dtry(InnerPort(■.s))\n        ),\n        rotational_friction(d=0.01),\n        Position(3, 5)\n      ),\n    ),\n    :tc => Dtry(\n      InnerBox(\n        Dtry(\n          :s => Dtry(InnerPort(■.s))\n        ),\n        tc,\n        Position(4, 4)\n      ),\n    ),\n  )\n)","category":"section"},{"location":"Examples/Motor/#Motor","page":"DC shunt motor","title":"Motor","text":"Now we interconnect the stator and rotor:\n\nmotor = CompositeSystem(\n  Dtry(\n    :q => Dtry(Junction(charge, Position(2, 1), exposed=true)),\n    :bₛ => Dtry(Junction(magnetic_flux, Position(2, 2), power=false)),\n    :p => Dtry(Junction(angular_momentum, Position(3, 3), exposed=true)),\n  ),\n  Dtry(\n    :stator => Dtry(\n      InnerBox(\n        Dtry(\n          :q => Dtry(InnerPort(■.q)),\n          :b => Dtry(InnerPort(■.bₛ, power=false)),\n        ),\n        stator,\n        Position(1, 2)\n      ),\n    ),\n    :rotor => Dtry(\n      InnerBox(\n        Dtry(\n          :q => Dtry(InnerPort(■.q)),\n          :bₛ => Dtry(InnerPort(■.bₛ, power=false)),\n          :p => Dtry(InnerPort(■.p)),\n        ),\n        rotor,\n        Position(3, 2)\n      ),\n    ),\n  )\n)","category":"section"},{"location":"Examples/Motor/#Evolution-equations","page":"DC shunt motor","title":"Evolution equations","text":"As the implementation does not yet support the simulation of open systems with 'boundary conditions', we can merely assemble the equations:\n\nassemble(motor)","category":"section"},{"location":"Examples/Motor/#EPHS.ComponentLibrary.ReversibleComponentLibrary.mkc-Examples-Motor","page":"DC shunt motor","title":"EPHS.ComponentLibrary.ReversibleComponentLibrary.mkc","text":"Magnetic-kinetic coupling: Reversible coupling of of a magnetic energy domain at port mathttb (magnetic flux) and a kinetic energy domain at port mathttp (angular momentum) based on the Lorentz force. The strength of the coupling is proportional to the magnetic flux at the state port mathttb_s. The Dirac structure is given by\n\nbeginbmatrix\n  mathttbf \n  mathttpf\nendbmatrix\n = \nbeginbmatrix\n  0  +mathttb_sx \n  -mathttb_sx  0\nendbmatrix\n\nbeginbmatrix\n  mathttbe \n  mathttpe\nendbmatrix\n\n\n\n\n\n\n","category":"constant"},{"location":"Examples/Oscillator/#Oscillator","page":"Oscillator","title":"Oscillator","text":"In the first part of this example, we consider a one-dimensional mass-spring oscillator, and in the second part, we reuse this system to form a mass-spring-damper system.\n\nBefore we start, let's load EPHS.jl and Plots.jl:\n\nusing EPHS, Plots","category":"section"},{"location":"Examples/Oscillator/#Mass-spring-oscillator","page":"Oscillator","title":"Mass-spring oscillator","text":"Following a bottom-up approach, we first define the primitive systems, and then we combine them into a composite system.","category":"section"},{"location":"Examples/Oscillator/#Storage-components","page":"Oscillator","title":"Storage components","text":"We start by defining two storage components that model storage of potential and kinetic energy:\n\npe = let\n  k = Par(:k, 1.5)                 # stiffness parameter with default value `1.5`\n  q = XVar(:q)                     # state variable for displacement of the spring\n  I = Dtry(                        # interface\n    :q => Dtry(displacement)       # power port defined by its quantity\n  )\n  E = Const(1/2) * k * q^Const(2)  # energy storage function\n  StorageComponent(I, E)\nend\n\nke = let\n  m = Par(:m, 1.)\n  p = XVar(:p)\n  I = Dtry(\n    :p => Dtry(momentum)\n  )\n  E = Const(1/2) * p^Const(2) / m\n  StorageComponent(I, E)\nend","category":"section"},{"location":"Examples/Oscillator/#Reversible-component","page":"Oscillator","title":"Reversible component","text":"Next, we define a reversible component that models the reversible coupling of the potential and kinetic energy domains:\n\npkc = ReversibleComponent(\n  Dtry(\n    :q => Dtry(ReversiblePort(FlowPort(displacement, -EVar(:p)))),\n    :p => Dtry(ReversiblePort(FlowPort(momentum, EVar(:q))))\n  )\n)\n\nA reversible component is defined by a skew-symmetric relation among the power variables:\n\nbeginbmatrix\n  mathttqf \n  mathttpf\nendbmatrix\n = \nbeginbmatrix\n  0  -1 \n  +1  0\nendbmatrix\n\nbeginbmatrix\n  mathttqe \n  mathttpe\nendbmatrix","category":"section"},{"location":"Examples/Oscillator/#Composite-system","page":"Oscillator","title":"Composite system","text":"We now define a Pattern, which interconnects the three components (in the only possible way):\n\nosc = CompositeSystem(\n  Dtry( # directory of junctions (energy domains)\n    :q => Dtry(Junction(displacement, Position(1, 2))),\n    :p => Dtry(Junction(momentum, Position(1, 4), exposed=true)),\n  ),\n  Dtry( # directory of inner boxes (subsystems)\n    :pe => Dtry(\n      InnerBox(\n        Dtry( # interface of box `pe`\n          :q => Dtry(InnerPort(■.q)), # assignment of port `pe.q` to junction `q`\n        ),\n        pe, # filling of the box\n        Position(1, 1)\n      ),\n    ),\n    :ke => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n        ),\n        ke,\n        Position(1, 5)\n      ),\n    ),\n    :pkc => Dtry(\n      InnerBox(\n        Dtry(\n          :q => Dtry(InnerPort(■.q)),\n          :p => Dtry(InnerPort(■.p))\n        ),\n        pkc,\n        Position(1, 3)\n      ),\n    ),\n  )\n)\n\nTo make the system extensible, the kinetic energy domain is exposed via an outer port.\n\nThe semantics of the composite system is the relation represented by the following equations:\n\nassemble(osc)\n\nIn the output, the state variable of a port, say pe.q, is shown as pe.q.x, while the flow and effort variables are shown as pe.q.f and pe.q.e, respectively.","category":"section"},{"location":"Examples/Oscillator/#Simulation","page":"Oscillator","title":"Simulation","text":"We define an initial condition as a directory:\n\nic = Dtry(\n  :pe => Dtry(\n    :q => Dtry(0.0),\n  ),\n  :ke => Dtry(\n    :p => Dtry(3.0),\n  ),\n)\n\nWe use the variational midpoint rule to simulate the dynamics of the oscillator:\n\nh = 0.01 # time step size\nt = 20.0 # duration of the simulation\nsim = simulate(osc, midpoint_rule, ic, h, t);\nnothing # hide","category":"section"},{"location":"Examples/Oscillator/#Plots","page":"Oscillator","title":"Plots","text":"We can plot the evolution of the displacement state variable pe.q.x:\n\nq = XVar(DtryPath(:pe), DtryPath(:q))\nplot_evolution(sim, q)\n\nWe can also plot the evolution of the total energy, the potential energy, and the kinetic energy:\n\nplot_evolution(sim,\n  \"total energy\" => total_energy(osc),\n  \"potential energy\" => total_energy(pe; box_path=DtryPath(:pe)),\n  \"kinetic energy\" => total_energy(ke; box_path=DtryPath(:ke));\n  ylims=(0, Inf), # Plots.jl attribute to set the y axis limits\n)","category":"section"},{"location":"Examples/Oscillator/#Mass-spring-damper-system","page":"Oscillator","title":"Mass-spring-damper system","text":"We first define the additionally required primitive systems, and then we combine them with the mass-spring oscillator.","category":"section"},{"location":"Examples/Oscillator/#Storage-component","page":"Oscillator","title":"Storage component","text":"We define a 'thermal capacity', i.e. a storage component that models storage of thermal energy:\n\ntc = let\n  c₁ = Par(:c₁, 0.5)\n  c₂ = Par(:c₂, 2.0)\n  s = XVar(:s)\n  E = c₁ * exp(s / c₂)\n  StorageComponent(\n    Dtry(\n      :s => Dtry(entropy)\n    ),\n    E\n  )\nend","category":"section"},{"location":"Examples/Oscillator/#Irreversible-component","page":"Oscillator","title":"Irreversible component","text":"Next, we define an irreversible component that models the irreversible process of mechanical friction:\n\nmf = let\n  d = Par(:d, 0.02)                     # friction coefficient\n  p₊e = EVar(:p)                        # effort (velocity)\n  s₊e = EVar(:s)                        # effort (temperature (wrt reference environment))\n  p₊f = d * p₊e                         # flow (damping force)\n  s₊f = -((d * p₊e * p₊e) / (θ₀ + s₊e)) # flow (entropy production)\n  IrreversibleComponent(\n    Dtry(\n      :p => Dtry(IrreversiblePort(momentum, p₊f)),\n      :s => Dtry(IrreversiblePort(entropy, s₊f))\n    )\n  )\nend\n\nAn irreversible component is defined by a symmetric, non-negative definite relation among the power variables:\n\nbeginbmatrix\n  mathttpf \n  mathttsf\nendbmatrix\n = \nfrac1theta_0  d \nbeginbmatrix\n  theta  -upsilon \n  - upsilon  fracupsilon^2theta\nendbmatrix\n\nbeginbmatrix\n  mathttpe \n  mathttse\nendbmatrix\n\nHere, upsilon = mathttpe is the velocity and theta = theta_0 + mathttse is the absolute temperature at which kinetic energy is dissipated into the thermal energy domain.\n\nThe condition for conservation of energy is satisfied:\n\nbeginbmatrix\n  0 \n  0\nendbmatrix\n = \nbeginbmatrix\n  theta  upsilon \n  - upsilon  fracupsilon^2theta\nendbmatrix\n\nbeginbmatrix\n  upsilon \n  theta\nendbmatrix","category":"section"},{"location":"Examples/Oscillator/#Composite-system-2","page":"Oscillator","title":"Composite system","text":"We can now define a Pattern, which interconnects the mass-spring oscillator and the two primitive systems that we have just defined:\n\ndamped_osc = CompositeSystem(\n  Dtry(\n    :p => Dtry(Junction(momentum, Position(1,2))),\n    :s => Dtry(Junction(entropy, Position(1,4))),\n  ),\n  Dtry(\n    :osc => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n        ),\n        osc,\n        Position(1,1)\n      ),\n    ),\n    :mf => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n          :s => Dtry(InnerPort(■.s)),\n        ),\n        mf,\n        Position(1,3)\n      ),\n    ),\n    :tc => Dtry(\n      InnerBox(\n        Dtry(\n          :s => Dtry(InnerPort(■.s)),\n        ),\n        tc,\n        Position(1,5)\n      ),\n    ),\n  )\n)\n\nThe semantics of the composite system is the relation represented by the following equations:\n\nassemble(damped_osc)","category":"section"},{"location":"Examples/Oscillator/#Simulation-2","page":"Oscillator","title":"Simulation","text":"ic2 = Dtry(\n  :osc => ic,\n  :tc => Dtry(\n    :s => Dtry(1.0)\n  ),\n)\n\nsim = simulate(damped_osc, midpoint_rule, ic2, h, t);\nnothing # hide","category":"section"},{"location":"Examples/Oscillator/#Plots-2","page":"Oscillator","title":"Plots","text":"q = XVar(DtryPath(:osc, :pe), DtryPath(:q))\nplot_evolution(sim, q)\n\nplot_evolution(sim,\n  \"total energy\" => total_energy(damped_osc),\n  \"potential energy\" => total_energy(pe; box_path=DtryPath(:osc, :pe)),\n  \"kinetic energy\" => total_energy(ke; box_path=DtryPath(:osc, :ke)),\n  \"thermal energy\" => total_energy(tc; box_path=DtryPath(:tc));\n  ylims=(0, Inf),\n  legend=:topright,\n)","category":"section"},{"location":"Reference/SymbolicExpressions/#SymbolicExpressions","page":"SymbolicExpressions","title":"SymbolicExpressions","text":"","category":"section"},{"location":"Reference/SymbolicExpressions/#EPHS.SymbolicExpressions","page":"SymbolicExpressions","title":"EPHS.SymbolicExpressions","text":"The SymblicExpressions module provides a simple computer algebra system (CAS). The concrete subtypes of SymExpr provide a mathematical syntax to symbolically represent the relations that define the semantics of primitive and composite systems.\n\n\n\n\n\n","category":"module"},{"location":"Reference/SymbolicExpressions/#EPHS.SymbolicExpressions.Const","page":"SymbolicExpressions","title":"EPHS.SymbolicExpressions.Const","text":"Const(value::Float64)\n\nWraps a Float64 literal as a SymExpr.\n\n\n\n\n\n","category":"type"},{"location":"Reference/SymbolicExpressions/#EPHS.SymbolicExpressions.Eq","page":"SymbolicExpressions","title":"EPHS.SymbolicExpressions.Eq","text":"Eq(lhs::SymExpr, rhs::SymExpr)\n\nEquation with a SymExpr on both sides of the equal sign.\n\nFields\n\nlhs: left hand side\nrhs: right hand side\n\n\n\n\n\n","category":"type"},{"location":"Reference/SymbolicExpressions/#EPHS.SymbolicExpressions.SymExpr","page":"SymbolicExpressions","title":"EPHS.SymbolicExpressions.SymExpr","text":"Abstract supertype for symbolic expressions. Abstract subtypes are SymVal for all leaf nodes (values) that may appear in syntax trees and SymOp for all internal nodes (operations) of a SymExpr.\n\n\n\n\n\n","category":"type"},{"location":"Reference/SymbolicExpressions/#EPHS.SymbolicExpressions.SymOp","page":"SymbolicExpressions","title":"EPHS.SymbolicExpressions.SymOp","text":"Abstract type for symbolic operations, i.e. internal nodes in a SymExpr syntax tree.\n\n\n\n\n\n","category":"type"},{"location":"Reference/SymbolicExpressions/#EPHS.SymbolicExpressions.SymVal","page":"SymbolicExpressions","title":"EPHS.SymbolicExpressions.SymVal","text":"Abstract type for symbolic values, i.e. leaf nodes in a SymExpr syntax tree.\n\n\n\n\n\n","category":"type"},{"location":"Reference/SymbolicExpressions/#EPHS.SymbolicExpressions.SymVar","page":"SymbolicExpressions","title":"EPHS.SymbolicExpressions.SymVar","text":"Abstract subtype of SymVal for symbolic variables, such as port variables, constraint variables, and parameters.\n\n\n\n\n\n","category":"type"},{"location":"Reference/SymbolicExpressions/#Base.diff-Tuple{SymExpr, SymVar}","page":"SymbolicExpressions","title":"Base.diff","text":"diff(expr::SymExpr, var::SymVar) -> SymExpr\n\nReturns the derivative of the given SymExpr with respect to the given SymVar using symbolic differentiation.\n\n\n\n\n\n","category":"method"},{"location":"Reference/SymbolicExpressions/#Base.foreach-Tuple{Function, SymExpr, Type{<:SymExpr}}","page":"SymbolicExpressions","title":"Base.foreach","text":"foreach(f, expr::SymExpr, T::Type{<:SymExpr}) -> nothing\n\nGoes from the root into the expression tree and whenever a node::T is encountered, calls f(node).\n\n\n\n\n\n","category":"method"},{"location":"Reference/SymbolicExpressions/#Base.replace-Tuple{Function, SymExpr, Type{<:SymExpr}}","page":"SymbolicExpressions","title":"Base.replace","text":"replace(f, expr::SymExpr, T::Type{<:SymExpr}) -> SymExpr\n\nTransforms a SymExpr using a function f : T -> SymExpr, where T <: SymExpr. Goes from the root into the expression tree and whenever a node::T is encountered, it is replaced by the new node f(node).\n\n\n\n\n\n","category":"method"},{"location":"Reference/SymbolicExpressions/#EPHS.SymbolicExpressions.ast-Tuple{SymExpr}","page":"SymbolicExpressions","title":"EPHS.SymbolicExpressions.ast","text":"ast(s::SymExpr) -> Expr\n\nTransform a SymExpr into a Julia Expr. Together with the methods called in the returned Julia Expr, ast defines the semantics of the mathematical SymExpr syntax.\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals/Patterns/#PatternsIntro","page":"Patterns","title":"Patterns","text":"Interconnection patterns provide a simple, graphical syntax for composing systems.","category":"section"},{"location":"Fundamentals/Patterns/#Example","page":"Patterns","title":"Example","text":"A pattern is defined by a directory of Junctions and a directory of InnerBoxes. For graphical display, junctions and inner boxes can be placed on a grid by annotating their Positions. Here is an example:\n\nusing EPHS # hide\nosc = Pattern(\n  Dtry( # junctions\n    :q => Dtry(Junction(displacement, Position(1, 2))),\n    :p => Dtry(Junction(momentum, Position(1, 4), exposed=true)),\n  ),\n  Dtry( # inner boxes\n    :pe => Dtry(\n      InnerBox(\n        Dtry(\n          :q => Dtry(InnerPort(■.q)),\n        ),\n        Position(1, 1)\n      ),\n    ),\n    :ke => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n        ),\n        Position(1, 5)\n      ),\n    ),\n    :pkc => Dtry(\n      InnerBox(\n        Dtry(\n          :q => Dtry(InnerPort(■.q)),\n          :p => Dtry(InnerPort(■.p))\n        ),\n        Position(1, 3)\n      ),\n    ),\n  )\n)\n\nThe Interface of each InnerBox is given by its directory of InnerPorts. Each port is connected to a Junction according to the given DtryPath. Since only ports with the same associated physical Quantity can be connected, the quantity is assigned only once at the junctions. The outer ports connected to the exposed junctions define the outer interface of the pattern.\n\nLet's briefly spell out the physical interpretation: Junctions represent energy domains. Here, junction q (displacement) on the left represents the potential energy domain and junction p(momentum) on the right represents the kinetic energy domain of a mechanical oscillator. Inner boxes represent (sub)systems, which are combined into a composite system according to the given pattern. Here, box pe represents storage of potential energy (spring) and box ke represents storage of kinetic energy (mass). Box pkc represents the potential-kinetic coupling, known as the (canonical) symplectic structure in mechanics.","category":"section"},{"location":"Fundamentals/Patterns/#Composition","page":"Patterns","title":"Composition","text":"To see how patterns compose, we need to define a second pattern:\n\ndamped_osc = Pattern(\n  Dtry(\n    :p => Dtry(Junction(momentum, Position(1, 2))),\n    :s => Dtry(Junction(entropy, Position(1, 4))),\n  ),\n  Dtry(\n    :osc => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n        ),\n        Position(1, 1)\n      ),\n    ),\n    :mf => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n          :s => Dtry(InnerPort(■.s)),\n        ),\n        Position(1, 3)\n      ),\n    ),\n    :tc => Dtry(\n      InnerBox(\n        Dtry(\n          :s => Dtry(InnerPort(■.s)),\n        ),\n        Position(1, 5)\n      ),\n    ),\n  )\n)\n\nThe two patterns are composable since the outer interface of the first pattern matches the interface of the inner box osc of the second pattern:\n\ninterface(osc) == interface(damped_osc, ■.osc)\n\nIn this way, a (reversible) oscillator model can be reused as a subsystem of a damped oscillator model. Box mf represents mechanical friction and box tc represents a thermal capacity that stores the dissipated energy.\n\nThe rest of this page is just an exercise to understand how composition works. It does not reflect how to use the framework in practice.\n\nPatterns are composable whenever interfaces match. This is made precise by demonstrating that the syntax forms a directory-multicategory with interfaces as objects and patterns as morphisms. However, this mathematical framework does not include positions for graphical display. Breaking down a complex system into small, manageable parts is meaningful only if the parts can be unambiguously composed, yielding again the original, complex system. The multicategory structure guarantees just that. As we do not intend to work directly with the flat, monolithic description, there is basically no need to display it graphically.\n\nTo illustrate visually what happens when we compose the two patterns defined above, we manually define the result, choosing the positions at will:\n\ndamped_osc_flat = Pattern(\n  Dtry(\n    :p => Dtry(Junction(momentum, Position(1, 4))),\n    :s => Dtry(Junction(entropy, Position(0, 5))),\n    :osc => Dtry(\n      :q => Dtry(Junction(displacement, Position(1, 2))),\n    ),\n  ),\n  Dtry(\n    :osc => Dtry(\n      :pe => Dtry(\n        InnerBox(\n          Dtry(\n            :q => Dtry(InnerPort(■.osc.q)),\n          ),\n          Position(1, 1)\n        ),\n      ),\n      :ke => Dtry(\n        InnerBox(\n          Dtry(\n            :p => Dtry(InnerPort(■.p)),\n          ),\n          Position(1, 5)\n        ),\n      ),\n      :pkc => Dtry(\n        InnerBox(\n          Dtry(\n            :q => Dtry(InnerPort(■.osc.q)),\n            :p => Dtry(InnerPort(■.p))\n          ),\n          Position(1, 3)\n        ),\n      ),\n    ),\n    :mf => Dtry(\n      InnerBox(\n        Dtry(\n          :p => Dtry(InnerPort(■.p)),\n          :s => Dtry(InnerPort(■.s)),\n        ),\n        Position(0, 4)\n      ),\n    ),\n    :tc => Dtry(\n      InnerBox(\n        Dtry(\n          :s => Dtry(InnerPort(■.s)),\n        ),\n        Position(0, 6)\n      ),\n    ),\n  )\n)\n\nWe can now assert that this is exactly what the mathematical framework gives us:\n\nosc = Pattern{Nothing,Nothing}(osc)\ndamped_osc = Pattern{Nothing,Nothing}(damped_osc)\ndamped_osc_flat = Pattern{Nothing,Nothing}(damped_osc_flat)\n\nid_mf = identity(interface(damped_osc, ■.mf))\nid_tc = identity(interface(damped_osc, ■.tc))\n\ncompose(damped_osc, Dtry(\n  :osc => Dtry(osc),\n  :mf => Dtry(id_mf),\n  :tc => Dtry(id_tc),\n)) == damped_osc_flat\n\nFirst, we reduced the three patterns to their mathematical content as morphisms. by reconstructing them with the Pattern{Nothing,Nothing}(::Pattern) constructor. Then, we constructed identity patterns/morphisms for the boxes/interfaces/objects mf and tc. Finally, we composed the morphism damped_osc with the morphism osc and the two identity morphisms. This indeed resulted in the morphism damped_osc_flat.\n\nTo conclude, it is straightforward to work with a hierarchy of simple patterns, rather than with a single complex pattern, because composition is uniquely defined and associative. Two adjacent levels of description are related, as they share interfaces in common. For each pattern on the lower-level, the outer box matches with an inner box of the pattern on the higher level. To form the composed/flattened pattern, for each port of each shared interface, the two assigned junctions (one on the lower-level and one on the higher-level) are identified.\n\nMore information about the Julia implementation of patterns is provided in the reference.","category":"section"},{"location":"Fundamentals/Patterns/#Functorial-semantics","page":"Patterns","title":"Functorial semantics","text":"Each port has associated variables, like the flow and effort variables known from bond graphs. At each junction, the variables of the connected ports satisfy a relation, similar to 0-junctions in bond graphs.\n\nThe outer box of a pattern as well as each of its inner boxes each represent an interface, given by a directory of ports, see interface(::Pattern) and interface(::Pattern, ::DtryPath). Since each port is connected to exactly one junction, the mathematical content of a pattern is a partition of all involved (inner and outer) ports. For instance, in the above pattern, the inner ports osc.pkc.p, osc.ke.p, and mf.p constitute one of the three parts (or junctions).\n\nTo use a pattern as a means to interconnect systems (whose interfaces match the inner boxes) into a composite system (whose interface matches the outer box), the mathematical content of the pattern needs to be translated into a relation among the associated port variables.\n\nState ports have a state variable and power ports additionally have a flow variable and an effort variable. Given a power port named p, its state, flow, and effort variables are denoted by p mathttx, p mathttf, and p mathtte, respectively. Considering for instance an interface I with two power ports named mathttp_1 and mathttp_2, as well as a state port named mathtts, its associated bundle of port variables mathcalP_I has seven port variables:\n\nleft(\n  mathttp_1x  mathttp_1f  mathttp_1e \n  mathttp_2x  mathttp_2f  mathttp_2e \n  mathttsx\nright)\n in \nmathcalP_I\n\nThe port variables form a vector bundle, where the state variables live in the base space and the flow/effort variables live in the corresponding tangent/cotangent spaces. For the moment, we simply assume that all port variables are real-valued. We can thus identify mathcalP_I cong mathbbR^7.\n\nAt every junction, the following holds:\n\nEquality of state: the state variables of all connected ports are equal.\nEquality of effort: the effort variables of all connected power ports are equal.\nEquality of net flow: the sum of the flow variables of all connected inner power ports is equal to the sum of the flow variables of all connected outer power ports.\n\nIn the remaining part of this page, we discuss some important mathematical aspects, which should be addressed in more detail in a future paper.\n\nThe translation from combinatorial syntax to relational semantics is mathematically understood as a functor F colon mathrmSyntax to mathrmRel. On objects, it sends an interface I to its bundle of port variables F(I) = mathcalP_I. On morphisms, it sends a pattern f to the relation F(f), defined by equality of state, equality of effort, and equality of net flow.\n\nFor instance, let's consider a pattern f with three inner boxes named mathtta, mathttb, and mathttc. Let I denote the interface of its outer box, called the outer interface of f. Further, Let I_a, I_b, and I_c denote the interfaces of the inner boxes. We write I_i = sum a mapsto I_a  b mapsto I_b  c mapsto I_c  for the combined interface, called the inner interface of f. Assuming that I_a has two ports named mathttq and mathttp, I_b has two ports named mathttp and mathtts, and I_c has one port named mathtts, the inner interface I_i has five ports named mathttaq, mathttap, mathttbp, mathttbs, and mathttcs. Here, sum denotes the named sum in the directory-multicategory mathrmSyntax. In contrast to a symmetric monoidal category (SMC), a directory-multicategory uses human-friendly names to combine objects or morphisms in parallel. This means that we don't have to worry about parentheses and coherence isomorphisms such as (I_a oplus I_b) oplus I_c cong I_a oplus (I_b oplus I_c), where oplus denotes the binary monoidal product of the equivalent SMC.\n\nAs a functor, F preserves source and target of morphisms. For the pattern f colon I_i to I, we hence get a relation of the form F(f) colon F(I_i) to F(I). To be more precise, we think of F as a lax directory-multifunctor to the directory-multicategory mathrmRel, cf. lax monoidal functor. This means that F comes with a natural transformation of the form sum a mapsto F(I_a)  b mapsto F(I_b)  c mapsto F(I_c) to F(sum a mapsto I_a  b mapsto I_b  c mapsto I_c ) for every parallel combination of interfaces. Again, we don't have to worry about the difference between, say, ((mathttaqx  mathttapx)  (mathttbpx  mathttbsx)) and (((mathttaqx  mathttapx)  mathttbpx)  mathttbsx), since the names already do the job. Precomposing (or 'whiskering') F with the 'lax' transformation, yields the semantics of the pattern f, given by a morphism in mathrmRel of the form sum a mapsto F(I_a)  b mapsto F(I_b)  c mapsto F(I_c) to F(I). This is simply a relation among the port variables of all involved interfaces, written in a way that distinguishes between the subsystems on one side and the composite system on the other side.\n\nAs a functor, F also preserves composite morphisms. This means that the semantics of patterns is well-behaved in the sense that we can flatten a hierarchy of patterns and then ask for the relation associated to the composed pattern, or we can ask for the relation associated to each pattern in the hierarchy and then compose those relations. Either way results in the same relation.","category":"section"},{"location":"Background/Discussion/#Discussion","page":"Discussion","title":"Discussion","text":"In this part we want to discuss how we would like to unite and enhance the benefits of bond graphs and port-Hamiltonian systems.","category":"section"},{"location":"Background/Discussion/#Bond-graphs","page":"Discussion","title":"Bond graphs","text":"subsystems are primitive elements\nit would be nice to allow arbitrarily complex subsystems\nthe composed system (network of elements) is itself closed\nit would be nice to allow open bond graphs (outer interface)\ncomposition (i.e. hierarchical nesting) of bond graphs should then ...\nexist whenever interfaces of systems match\nbe unique, given no further data than the bond graphs to be composed\nbe associative (unique flattened hierarchy of bond graphs)","category":"section"},{"location":"Background/Discussion/#Port-Hamiltonian-systems","page":"Discussion","title":"Port-Hamiltonian systems","text":"port-Hamiltonian systems compose according to extra data (\"interconnecting Dirac structure\")\nit would be nice to have them compose according to graphical syntax similar to bond graphs, that is composable just like the systems themselves\nsubsystems and their (inner) ports are not explicit in representations of port-Hamiltonian systems\nit would be nice to have subsystems and system interfaces as explicit parts of the framework","category":"section"},{"location":"Background/Discussion/#Conclusion","page":"Discussion","title":"Conclusion","text":"bond graphs provide a network representation of systems, but the representation is not composable as such, at least not without specifying extra data\nport-Hamiltonian systems are composable, but composite systems are not defined using a graphical syntax similar to bond graphs\n\nCan we combine these great inventions/discoveries to get something even more powerful?\n\nOur answer is sketched out on the next page.","category":"section"},{"location":"Reference/Patterns/#Patterns","page":"Patterns","title":"Patterns","text":"","category":"section"},{"location":"Reference/Patterns/#EPHS.Patterns","page":"Patterns","title":"EPHS.Patterns","text":"The Patterns module defines interconnection Patterns, which provide a graphical syntax for expressing a power-preserving interconnection of finitely many subsystems into a single composite system. Since subsystems may again have yet simpler subsystems, patterns can be composed, i.e. hierarchically nested. Whenever the outer interface of a pattern matches a subsystem interface of another pattern, the patterns can be composed.\n\n\n\n\n\n","category":"module"},{"location":"Reference/Patterns/#EPHS.Patterns.InnerBox","page":"Patterns","title":"EPHS.Patterns.InnerBox","text":"InnerBox(ports::Dtry{InnerPort}, filling::F, position::P) where {{F<:Union{Nothing,AbstractSystem},P<:Union{Nothing,Position}}\n\nAn InnerBox represents a subsystem, whose Interface is given as a directory of ports, see InnerPort.\n\nTo define systems hierarchically, a filling is assigned, which is a system whose interface matches that of the box.\n\nFields\n\nports: directory of ports defining the Interface of the box\nfilling: nothing or an AbstractSystem filling the box\nposition: nothing or a grid Position\n\n\n\n\n\n","category":"type"},{"location":"Reference/Patterns/#EPHS.Patterns.InnerBox-Tuple{Dtry{InnerPort}, AbstractSystem, Position}","page":"Patterns","title":"EPHS.Patterns.InnerBox","text":"InnerBox(ports::Dtry{InnerPort}, filling::AbstractSystem, position::Position)\n\nAn InnerBox represents a subsystem, whose Interface is given as a directory of ports, see InnerPort.\n\nTo define systems hierarchically, a filling is assigned, which is a system whose interface matches that of the box.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.Patterns.InnerBox-Tuple{Dtry{InnerPort}, AbstractSystem}","page":"Patterns","title":"EPHS.Patterns.InnerBox","text":"InnerBox(ports::Dtry{InnerPort}, filling::AbstractSystem)\n\nAn InnerBox represents a subsystem, whose Interface is given as a directory of ports, see InnerPort.\n\nTo define systems hierarchically, a filling is assigned, which is a system whose interface matches that of the box.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.Patterns.InnerBox-Tuple{Dtry{InnerPort}, Position}","page":"Patterns","title":"EPHS.Patterns.InnerBox","text":"InnerBox(ports::Dtry{InnerPort}, position::Position)\n\nAn InnerBox represents a subsystem, whose Interface is given as a directory of ports, see InnerPort.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.Patterns.InnerBox-Tuple{Dtry{InnerPort}}","page":"Patterns","title":"EPHS.Patterns.InnerBox","text":"InnerBox(ports::Dtry{InnerPort})\n\nAn InnerBox represents a subsystem, whose Interface is given as a directory of ports, see InnerPort.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.Patterns.InnerPort","page":"Patterns","title":"EPHS.Patterns.InnerPort","text":"InnerPort(junction::DtryPath, power::Bool)\n\nAn InnerPort is a port of an InnerBox, which is connected to the Junction with the given DtryPath in the directory of junctions, see Pattern. If power=false the port is a state port, which may exchange information about the state of the quantity associated to the junction. If power=true the port is a power port, which may additionally exchange energy by exchanging the associated quantity.\n\nFields\n\njunction: DtryPath to the assigned junction\npower: false means state port, true means power port\n\n\n\n\n\n","category":"type"},{"location":"Reference/Patterns/#EPHS.Patterns.InnerPort-Tuple{DtryPath}","page":"Patterns","title":"EPHS.Patterns.InnerPort","text":"InnerPort(junction::DtryPath; power::Bool=true)\n\nAn InnerPort is a port of an InnerBox, which is connected to the Junction with the given DtryPath in the directory of junctions, see Pattern. If power=false the port is a state port, which may exchange information about the state of the quantity associated to the junction. If power=true the port is a power port, which may additionally exchange energy by exchanging the associated quantity.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.Patterns.Junction","page":"Patterns","title":"EPHS.Patterns.Junction","text":"Junction{P}(quantity::Quantity, position::P, exposed::Bool, power::Bool) where {P<:Union{Nothing,Position}}\n\nA junction represents an energy domain, where the connected ports may exchange information about the state of the given quantity and where the connected power ports may additionally exchange energy by exchanging the given quantity. If exposed=true an outer port is added, which is a power port if power=true.\n\nFields\n\nquantity: associated Quantity\nposition: nothing or a grid Position\nexposed: true means the junction has a connected outer port\npower: if exposed, determines if the outer port is a power port\n\n\n\n\n\n","category":"type"},{"location":"Reference/Patterns/#EPHS.Patterns.Junction-Tuple{Quantity, Position}","page":"Patterns","title":"EPHS.Patterns.Junction","text":"Junction(quantity::Quantity, position::Position; exposed::Bool=false, power::Bool=true)\n\nA junction represents an energy domain, where the connected ports may exchange information about the state of the given quantity and where the connected power ports may additionally exchange energy by exchanging the given quantity. If exposed=true an outer port is added, which is a power port if power=true.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.Patterns.Junction-Tuple{Quantity}","page":"Patterns","title":"EPHS.Patterns.Junction","text":"Junction(quantity::Quantity; exposed::Bool=false, power::Bool=true)\n\nA junction represents an energy domain, where the connected ports may exchange information about the state of the given quantity and where the connected power ports may additionally exchange energy by exchanging the given quantity. If exposed=true an outer port is added, which is a power port if power=true.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.Patterns.Pattern","page":"Patterns","title":"EPHS.Patterns.Pattern","text":"Pattern{F,P}(junctions::Dtry{Junction{P}}, boxes::Dtry{InnerBox{F,P}}) where {F<:Union{Nothing,AbstractSystem},P<:Union{Nothing,Position}}\n\nA (interconnection) Pattern is defined by a directory of (possibly exposed) Junctions and a directory of InnerBoxes (subsystems), whose ports are assigned to junctions, see InnerPort. The constructor checks that\n\njunctions and boxes have disjoint namespaces\nevery port is connected/assigned to an existing junction\nevery junction has at least one connected inner port\n\nFields\n\njunctions: directory of junctions\nboxes: directory of inner boxes (subsystems)\n\n\n\n\n\n","category":"type"},{"location":"Reference/Patterns/#EPHS.Patterns.Pattern-Union{Tuple{Pattern}, Tuple{Nothing}} where Nothing","page":"Patterns","title":"EPHS.Patterns.Pattern","text":"Pattern{Nothing,Nothing}(pattern::Pattern{F,P})\n\nReduce a Pattern{F,P} to a Pattern{Nothing,Nothing} by forgetting the filling of boxes as well as the positions of junctions and boxes.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.Patterns.Pattern-Union{Tuple{P}, Tuple{F}, Tuple{Dtry{Junction{P}}, Dtry{InnerBox{F, P}}}} where {F<:Union{Nothing, AbstractSystem}, P<:Union{Nothing, Position}}","page":"Patterns","title":"EPHS.Patterns.Pattern","text":"Pattern(junctions::Dtry{Junction{P}}, boxes::Dtry{InnerBox{F,P}}) where {F<:Union{Nothing,AbstractSystem},P<:Union{Nothing,Position}}\n\nA (interconnection) Pattern is defined by a directory of (possibly exposed) Junctions and a directory of InnerBoxes (subsystems), whose ports are assigned to junctions, see InnerPort. The constructor checks that\n\njunctions and boxes have disjoint namespaces\nevery port is connected/assigned to an existing junction\nevery junction has at least one connected inner port\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.Patterns.Position","page":"Patterns","title":"EPHS.Patterns.Position","text":"Position(r::Int, c::Int)\n\nPosition of a Junction or InnerBox used to graphically represent a Pattern.\n\nFields\n\nr: row index on grid\nc: column index on grid\n\n\n\n\n\n","category":"type"},{"location":"Reference/Patterns/#Base.identity-Tuple{Dtry{PortType}}","page":"Patterns","title":"Base.identity","text":"identity(x::Interface) -> Pattern{Nothing,Nothing}\n\nReturn the identity Pattern on the given Interface.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.AbstractSystems.interface-Tuple{Pattern, DtryPath}","page":"Patterns","title":"EPHS.AbstractSystems.interface","text":"interface(pattern::Pattern, box_path::DtryPath) -> Interface\n\nReturns the Interface of the InnerBox with the given path.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.AbstractSystems.interface-Tuple{Pattern}","page":"Patterns","title":"EPHS.AbstractSystems.interface","text":"interface(pattern::Pattern) -> Interface\n\nReturns the outer Interface of the given Pattern.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.Patterns.compose-Tuple{Pattern{Nothing, Nothing}, Dtry{Pattern{Nothing, Nothing}}}","page":"Patterns","title":"EPHS.Patterns.compose","text":"compose(pattern::Pattern{Nothing,Nothing}, fillings::Dtry{Pattern{Nothing,Nothing}}) -> Pattern{Nothing,Nothing}\n\nComposition operation for the Dtry-multicategory of patterns.\n\nArguments\n\npattern: top-level Pattern\nfillings: directory of patterns, which assigns to each InnerBox of the top-level pattern a nested pattern\n\n\n\n\n\n","category":"method"},{"location":"Reference/Patterns/#EPHS.Patterns.grid_dimensions-Union{Tuple{Pattern{F, Position}}, Tuple{F}} where F","page":"Patterns","title":"EPHS.Patterns.grid_dimensions","text":"Get the dimensions of the outer box on the grid. Returns r_min, r_max, c_min, c_max (minimal/maximal row/column index).\n\n\n\n\n\n","category":"method"},{"location":"Fundamentals/Directories/#DirectoriesIntro","page":"Directories","title":"Directories","text":"Directories provide a monadic data structure for hierarchically-organized information.","category":"section"},{"location":"Fundamentals/Directories/#Example","page":"Directories","title":"Example","text":"Let's start with an example that specifies (real-valued) initial conditions of a model:\n\nusing EPHS # hide\nic = Dtry(\n  :oscillator => Dtry(\n    :spring => Dtry(\n      :q => Dtry(1.0),\n    ),\n    :mass => Dtry(\n      :p => Dtry(0.0),\n    ),\n  ),\n  :thermal_capacity => Dtry(\n    :s => Dtry(16.56)\n  ),\n)\n\nWe can then access any subdirectory using its name:\n\nic.oscillator\n\nSo, directories are trees (or tries), where the leaves hold values of a given type. The leaves are primitive subdirectories:\n\nic.thermal_capacity.s\n\nOf course, we can also access the values directly:\n\nic.thermal_capacity.s[]","category":"section"},{"location":"Fundamentals/Directories/#Paths","page":"Directories","title":"Paths","text":"A DtryPath is given by a sequence of names, usually used to indicate the path from the root (represented by ■) to a leaf:\n\npath::DtryPath = ■.oscillator.spring.q\nic[path]","category":"section"},{"location":"Fundamentals/Directories/#Monad-structure","page":"Directories","title":"Monad structure","text":"A monad is an endofunctor with extra structure. So, in a category of types (objects) and functions (morphisms), a monad is basically a type, which is parametrized by another type, as is the case for either lists or directories of, say, floating-point numbers.\n\ntypeof(ic)\n\nGiven a category C, an endofunctor F colon C to C is a monad if it is equipped with two operations (natural transformations) satisfying certain diagrams (algebraic laws). For any object T in C, we have\n\nmathrmunit colon T to FT\nmathrmflatten colon FFT to FT\n\nThe first function is the unit of the monad and the second function is the monad multiplication.\n\nIn Julia, the unit of the directory monad is implemented by the constructor Dtry(value::T). It turns a value of type T into a directory of Ts that contains just the given value:\n\nT = Int\nx::T = 42\ndtry::Dtry{T} = Dtry(x)\n\nThe monad multiplication is implemented by the function flatten(::Dtry{Dtry{T}) that returns a Dtry{T}. It takes the values/directories of the outer directory and grafts them directly onto it, replacing its original leaves. To illustrate this, we define a directory of directories of floating-point numbers and then flatten it:\n\nnested_dtry = Dtry(\n  :osc => Dtry(ic.oscillator), # directory as value!\n  :tc => Dtry(ic.thermal_capacity)\n)\nflatten(nested_dtry)\n\nMore information about the Julia implementation of directories is provided in the reference.","category":"section"},{"location":"Reference/Overview/#Reference","page":"Overview","title":"Reference","text":"","category":"section"},{"location":"Reference/Overview/#EPHS.Directories-Reference-Overview","page":"Overview","title":"EPHS.Directories","text":"Directories - the NonEmptyDtry and Dtry monads\n\nA nonempty directory of Ts (NonEmptyDtry{T}) is essentially a tree whose leaves hold values of type T. Each value is addressed by the path from the root node to the respective leaf, given by a list of Symbols, see DtryPath.\n\nThe monad unit sends a value of type T to a tree consisting only of a leaf holding the value.\n\nThe monad multiplication flattens a directory of directories of Ts into a directory of Ts by grafting the trees stored at the leaves directly onto their respective parent nodes.\n\nA (possibly empty) directory of Ts (Dtry{T}) is either empty or it is a nonempty directory of Ts. The Dtry monad is hence obtained by composing the NonEmptyDtry monad with the 'Maybe monad'. The composition of the monads relies on a distributive law. Since subdirectories (subtrees) of a directory cannot be empty, the distributive law filters out any empty directories at the leaves, as they cannot be grafted onto their parent nodes.\n\nThis module implements directories as an immutable data structure. Subdirectories are stored in lexicographic order to ensure that two directories with the same set of paths (namespace) and the same associated values are equal.\n\nThe implementation supports simple access of subdirectories and values, pretty-printing, iteration, mapping, filtering, merging, etc.\n\n\n\n\n\n","category":"module"},{"location":"Reference/Overview/#EPHS.SymbolicExpressions-Reference-Overview","page":"Overview","title":"EPHS.SymbolicExpressions","text":"The SymblicExpressions module provides a simple computer algebra system (CAS). The concrete subtypes of SymExpr provide a mathematical syntax to symbolically represent the relations that define the semantics of primitive and composite systems.\n\n\n\n\n\n","category":"module"},{"location":"Reference/Overview/#EPHS.AbstractSystems-Reference-Overview","page":"Overview","title":"EPHS.AbstractSystems","text":"The AbstractSystems module provides a common basis for the graphical syntax defined in EPHS.Patterns and the semantics defined in EPHS.Components and EPHS.CompositeSystems. Specifically, the module defines system interfaces (see Interface), an abstract type for concrete systems (see AbstractSystem), and port variables (see PortVar).\n\n\n\n\n\n","category":"module"},{"location":"Reference/Overview/#EPHS.Patterns-Reference-Overview","page":"Overview","title":"EPHS.Patterns","text":"The Patterns module defines interconnection Patterns, which provide a graphical syntax for expressing a power-preserving interconnection of finitely many subsystems into a single composite system. Since subsystems may again have yet simpler subsystems, patterns can be composed, i.e. hierarchically nested. Whenever the outer interface of a pattern matches a subsystem interface of another pattern, the patterns can be composed.\n\n\n\n\n\n","category":"module"},{"location":"Reference/Overview/#EPHS.Components-Reference-Overview","page":"Overview","title":"EPHS.Components","text":"The Components module defines the primitive systems: StorageComponents, ReversibleComponents, and IrreversibleComponents.\n\n\n\n\n\n","category":"module"},{"location":"Reference/Overview/#EPHS.CompositeSystems-Reference-Overview","page":"Overview","title":"EPHS.CompositeSystems","text":"The CompositeSystems module defines CompositeSystems and provides the means to assemble them into systems of differential(-algebraic) equations, see DAESystem and assemble.\n\n\n\n\n\n","category":"module"},{"location":"Reference/Overview/#EPHS.Simulations-Reference-Overview","page":"Overview","title":"EPHS.Simulations","text":"The Simulations module provides the simulate function to compute the time evolution of composite systems, starting from an initial condition. As an argument, the function takes a numerical method, such as midpoint_rule. Based on the DAESystem obtained from the CompositeSystem, this method generates Julia code, which is then called in a time-stepping loop. Further, the module provides functionality for post-processing and plotting of the SimulationResult, see evolution and plot_evolution.\n\n\n\n\n\n","category":"module"},{"location":"Vision/#Vision","page":"Vision","title":"Current limitations and a vision for the future","text":"A major limitation of EPHS.jl is its computer algebra system (CAS) used to express equations/relations. At present, the CAS assumes that port variables are real-valued scalars, rather than elements of some vector space, or even more generally, of a Lie group or Lie algebra.\n\nAs applications that require a more general CAS, we have theoretically studied multibody systems (formulated based on the Lie group of Euclidean isometries) as well as fluid and plasma models (formulated using exterior calculus):\n\nExergetic port-Hamiltonian systems for multibody dynamics\nEnergy-based, geometric, and compositional formulation of fluid and plasma models\n\ntip: Tip\nThe main goal of this proof of concept is to encourage the emergence of one or more community-driven port-Hamiltonian software frameworks. Through united effort, the well-recognized strengths of port-Hamiltonian systems, such as modularity and structure preservation, can move beyond theory and begin to deliver practical impact. This work is guided by the strong conviction that, for port-Hamiltonian modeling to truly gain traction, composability must not only be theoretically possible, but also seamless and intuitive in practice.","category":"section"},{"location":"Background/PortBased/#Port-based-modeling","page":"Port-based modeling","title":"Port-based modeling","text":"Port-based modeling is concerned with networks of open physical systems that exchange energy via (power) ports. In the context of physical modeling, the use of modularity to handle complexity has been pioneered for instance by Kron's \"Method of Tearing\" (aka Diakoptics).","category":"section"},{"location":"Background/PortBased/#Bond-graphs","page":"Port-based modeling","title":"Bond graphs","text":"Bond graphs provide a graphical notation for models of physical systems:\n\nnodes/elements are primitive subsystems\ngeneralized capacitors, inductors, resistors, transformers, gyrators, etc.\n0-junctions and 1-junctions as generalized Kirchhoff circuit laws\nedges/bonds model energy exchange between subsystems\n\nBond graphs provide an energy-based alternative to \"linear graphs\", as known from electrical circuit diagrams. While linear graphs are also commonly used in other physical domains, such as acoustics, the energy-based approach of bond graphs makes them well-suited for \"multi-physical models\".","category":"section"},{"location":"Background/PortBased/#Port-Hamiltonian-systems","page":"Port-based modeling","title":"Port-Hamiltonian systems","text":"Inspired by bond graphs, port-Hamiltonian systems provide a framework which uses Dirac structures not only to allow for dynamical invariants and algebraic constraints, but also to add external power ports. The Dirac structure models the lossless exchange of energy within the system and across its interface, given by the external ports. Some of these ports may however also be \"closed\" internally by a \"resistive relation\". This models a dissipative (as opposed to a lossless) dynamics, which removes energy from the system.\n\nVarious classes of ODEs/DAEs/PDEs/PDAEs with (external) ports are port-Hamiltonian, meaning that\n\neach class is closed under power-preserving interconnection (composition)\nstructure guarantees passivity and power balance\nstored power + dissipated power = power supplied via ports\ndissipated power ≥ 0\n\nA power-preserving interconnection is given by an \"interconnecting Dirac structure\", which is composed with the Dirac structures of the subsystems to define the Dirac structure of the composed system.","category":"section"},{"location":"Background/Overview/#Background","page":"Overview","title":"Background","text":"First, let's have a look at the historical/scientific background of this project. Specifically, we want to summarize and discuss the paradigms of energy-based modeling as well as port-based modeling of (classical) physical systems. In the final part of the section, we want to outline how our approach integrates both paradigms.\n\nPages = [\n  \"EnergyBased.md\",\n  \"PortBased.md\",\n  \"Discussion.md\",\n  \"Approach.md\",\n]\nDepth = 1","category":"section"},{"location":"Background/Approach/#The-approach-behind-EPHS.jl","page":"The approach behind EPHS.jl","title":"The approach behind EPHS.jl","text":"","category":"section"},{"location":"Background/Approach/#Compositionality","page":"The approach behind EPHS.jl","title":"Compositionality","text":"EPHS formalizes modularity and hierarchical nesting of systems based on a simple, graphical syntax, using ideas from (applied) category theory.\n\nexplicit separation of syntax and semantics (as different categories)\ncompatibility of composition operations for interconnection patterns (syntax) and systems/relations (semantics) is a functor property (cf. Lawvere's functorial semantics)\nuse of directories as a data structure for hierarchically-organized information\ndirectories have the algebraic structure of a monad\ndirectory-multicategories essentially are a strictification of symmetric monoidal categories\nidea: combine objects (system interfaces and systems) and morphisms (interconnection patterns and composite systems) in parallel, using human-friendly names instead of a binary monoidal product (i.e. a bifunctor that has to satisfy coherence diagrams)\n\nWhile the jargon of category theory is likely not attractive to users, designing a compositional framework with these ideas in mind helps to arrive at an ultimately quite simple setup.","category":"section"},{"location":"Background/Approach/#Thermodynamic-modeling","page":"The approach behind EPHS.jl","title":"Thermodynamic modeling","text":"Whenever the hierarchy of nested subsystems is (made) flat, the remaining subsystems are primitive components. Inspired by the metriplectic or GENERIC framework, the relations that define (the behavior of) the components have a structure that implies a thermodynamically consistent reversible-irreversible splitting. It follows that the first law and second law hold for arbitrarily composed EPHS models. In the jargon of port-Hamiltonian systems, this is achieved first and foremost by replacing the energy storage function (or \"Hamiltonian\") with an exergy storage function (also called available energy), as discussed in more detail in the first EPHS paper.\n\nExpressions in the graphical syntax (interconnection patterns) can be directly interpreted as energy/exergy flow diagrams, as used in (engineering) thermodynamics (or \"thermodynamic optimization\" or \"exergy analysis\").","category":"section"},{"location":"Reference/CompositeSystems/#CompositeSystems","page":"CompositeSystems","title":"CompositeSystems","text":"","category":"section"},{"location":"Reference/CompositeSystems/#EPHS.CompositeSystems","page":"CompositeSystems","title":"EPHS.CompositeSystems","text":"The CompositeSystems module defines CompositeSystems and provides the means to assemble them into systems of differential(-algebraic) equations, see DAESystem and assemble.\n\n\n\n\n\n","category":"module"},{"location":"Reference/CompositeSystems/#EPHS.CompositeSystems.CompositeSystem-Union{Tuple{CompositeSystem{Position}}, Tuple{Nothing}} where Nothing","page":"CompositeSystems","title":"EPHS.CompositeSystems.CompositeSystem","text":"CompositeSystem{Nothing}(sys::CompositeSystem{Position})\n\nReduce a CompsiteSystem{Position} to a CompositeSystem{Nothing} by forgetting the the positions of junctions and boxes.\n\n\n\n\n\n","category":"method"},{"location":"Reference/CompositeSystems/#EPHS.CompositeSystems.CompositeSystem-Union{Tuple{P}, Tuple{Dtry{Junction{P}}, Dtry{InnerBox{AbstractSystem, P}}}} where P<:Union{Nothing, Position}","page":"CompositeSystems","title":"EPHS.CompositeSystems.CompositeSystem","text":"CompositeSystem(junctions::Dtry{Junction{P}}, boxes::Dtry{InnerBox{AbstractSystem,P}}) where {P<:Union{Nothing,Position}}\n\nA CompositeSystem is given by a Pattern, where each InnerBox is filled by a system whose interface matches that of the box.\n\n\n\n\n\n","category":"method"},{"location":"Reference/CompositeSystems/#EPHS.CompositeSystems.Connection","page":"CompositeSystems","title":"EPHS.CompositeSystems.Connection","text":"Connection of an InnerPort to a Junction\n\n\n\n\n\n","category":"type"},{"location":"Reference/CompositeSystems/#EPHS.CompositeSystems.DAEConstraint","page":"CompositeSystems","title":"EPHS.CompositeSystems.DAEConstraint","text":"DAEConstraint(cvar::CVar, residual::SymExpr)\n\nThe residual is forced to be zero by the corresponding constraint variable cvar.\n\n\n\n\n\n","category":"type"},{"location":"Reference/CompositeSystems/#EPHS.CompositeSystems.DAEStorage","page":"CompositeSystems","title":"EPHS.CompositeSystems.DAEStorage","text":"DAEStorage(xvar::XVar, quantity::Quantity, flow::SymExpr, effort::SymExpr)\n\nFields\n\nxvar: state variable\nquantity: associated [EPHS.AbstractSystems.Quantity]\nflow: the time-derivative of the state variable\neffort: the differential of the exergy function w.r.t. the state variable\n\n\n\n\n\n","category":"type"},{"location":"Reference/CompositeSystems/#EPHS.CompositeSystems.DAESystem","page":"CompositeSystems","title":"EPHS.CompositeSystems.DAESystem","text":"DAESystem(storage::Vector{DAEStorage}, constraints::Vector{DAEConstraint})\n\nA DAESystem defines a system of differential(-algebraic) equations.\n\nFields\n\nstorage: differential part (evolution of state variables)\nconstraints: algebraic part (residuals forced to be zero by constraint variables)\n\nSee DAEStorage and DAEConstraint.\n\n\n\n\n\n","category":"type"},{"location":"Reference/CompositeSystems/#EPHS.CompositeSystems.FlatSystem","page":"CompositeSystems","title":"EPHS.CompositeSystems.FlatSystem","text":"FlatSystem(pattern::Pattern, connections::Dtry(Vector(Connection)))\n\nA flat system is a composite system without any hierarchical nesting of (sub-)systems. This struct also controls if each junction has only one provider of effort and state.\n\n\n\n\n\n","category":"type"},{"location":"Reference/CompositeSystems/#EPHS.CompositeSystems.assemble-Tuple{CompositeSystem}","page":"CompositeSystems","title":"EPHS.CompositeSystems.assemble","text":"assemble(sys::CompositeSystem) -> DAESystem\n\nAssemble the system of differential(-algebraic) equations corresponding to the given CompositeSystem.\n\n\n\n\n\n","category":"method"},{"location":"Reference/CompositeSystems/#EPHS.CompositeSystems.update_parameters-Tuple{DAESystem, AbstractDtry{Float64}}","page":"CompositeSystems","title":"EPHS.CompositeSystems.update_parameters","text":"update_parameters(dae::DAESystem, ps::Dtry{Float64}) -> DAESystem\n\nUpdate the parameters of the given DAESystem according to the directory of parameters ps. Parameters that are not contained in ps remain unchanged. Parameters in ps that are not present in the system are ignored.\n\n\n\n\n\n","category":"method"},{"location":"Reference/CompositeSystems/#EPHS.MoreBase.flatten-Union{Tuple{CompositeSystem{P}}, Tuple{P}} where P","page":"CompositeSystems","title":"EPHS.MoreBase.flatten","text":"MoreBase.flatten(sys::CompositeSystem{P}) ->\n\nThe function flatten creates a flat system from a nested composite system using recursion.\n\nnested subsystems are converted into non-hierarchical systems\nconnections, ports, and junctions are adjusted to assure consistency\n\n\n\n\n\n","category":"method"},{"location":"Reference/Simulations/#Simulations","page":"Simulations","title":"Simulations","text":"","category":"section"},{"location":"Reference/Simulations/#EPHS.Simulations","page":"Simulations","title":"EPHS.Simulations","text":"The Simulations module provides the simulate function to compute the time evolution of composite systems, starting from an initial condition. As an argument, the function takes a numerical method, such as midpoint_rule. Based on the DAESystem obtained from the CompositeSystem, this method generates Julia code, which is then called in a time-stepping loop. Further, the module provides functionality for post-processing and plotting of the SimulationResult, see evolution and plot_evolution.\n\n\n\n\n\n","category":"module"},{"location":"Reference/Simulations/#EPHS.Simulations.SimulationResult","page":"Simulations","title":"EPHS.Simulations.SimulationResult","text":"SimulationResult(\n    sys::CompositeSystem,\n    dae::DAESystem,\n    method::Function,\n    h::Float64,\n    xs::Vector\n)\n\nData structure returned by simulate.\n\nFields\n\nsys: CompositeSystem\ndae: the resulting DAESystem obtaind by assemble(sys)\nmethod: the numerical method (e.g. midpoint_rule)\nh: time step size\nxs: simulation result (xs[1] is initial condition)\n\n\n\n\n\n","category":"type"},{"location":"Reference/Simulations/#EPHS.Simulations.evolution-Tuple{SimulationResult, SymExpr}","page":"Simulations","title":"EPHS.Simulations.evolution","text":"evolution(sim::SimulationResult, expr::SymExpr)\n\nEvaluates the given SymExpr at each time step, given that the expression depends only on the state variables.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Simulations/#EPHS.Simulations.evolution-Tuple{SimulationResult, XVar}","page":"Simulations","title":"EPHS.Simulations.evolution","text":"evolution(sim::SimulationResult, xvar::Xvar)\n\nReturns a Vector{Float64} containing the values of the given state variable at each time instant.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Simulations/#EPHS.Simulations.midpoint_rule-Tuple{DAESystem}","page":"Simulations","title":"EPHS.Simulations.midpoint_rule","text":"midpoint_rule(dae::DAESystem)\n\nGenerate a Julia function that performs a state update x₀ ↦ x₁ based on the implicit midpoint discretization. This is a symplectic, second-order Gauss method. For constrained systems, the state is augmented with the constraint variables.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Simulations/#EPHS.Simulations.nlsolve-Tuple{Function, AbstractVector}","page":"Simulations","title":"EPHS.Simulations.nlsolve","text":"nlsolve(residual::Function, x₀::AbstractVector)\n\nSolves the system of nonlinear equations residual(x) ≈ 0 using the Newton-Raphson method with x = x₀ as the initial guess.\n\nExample\n\njulia> using StaticArrays\n\njulia> residual(x) = SA[x[1]-x[2]+2, x[1]*x[1]-x[2]];\n\njulia> x₀ = SA[0., 0.];\n\njulia> nlsolve(residual, x₀) ≈ SA[-1., 1.]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"Reference/Simulations/#EPHS.Simulations.simulate-Tuple{CompositeSystem, Function, AbstractDtry{Float64}, Real, Real}","page":"Simulations","title":"EPHS.Simulations.simulate","text":"simulate(\n  sys::CompositeSystem,\n  method::Function,\n  ic::Union{Vector, AbstractDtry{Float64}},\n  h::Real,\n  tₑ::Real;\n  ps::AbstractDtry{Float64}=Dtry{Float64}()\n) -> SimulationResult\n\nSimulate the evolution of an isolated CompositeSystem.\n\nArguments\n\nsys: the isolated system\nmethod: the numerical method used for simulation\nic: directory of initial conditions for the state variables of all storage components\nh: time step size\ntₑ: final time (duration of simulation)\nps: directory of parameters to update before simulation (optional keyword argument)\n\nReturns a SimulationResult.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Simulations/#EPHS.Simulations.timegrid-Tuple{SimulationResult}","page":"Simulations","title":"EPHS.Simulations.timegrid","text":"timegrid(sim::SimulationResult)\n\nReturns a Vector{Float64} of time instants separated by the time step size sim.h.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Simulations/#EPHS.Simulations.plot_convergence-Tuple{CompositeSystem, AbstractDtry{Float64}, Vector{Float64}, Real, SymExpr, Function, Function, Vector{Int64}}","page":"Simulations","title":"EPHS.Simulations.plot_convergence","text":"plot_convergence(\n    sys::CompositeSystem,\n    ic::AbstractDtry{64},\n    hs::Vector{Float64},\n    t::Real,\n    expr::SymExpr,\n    error::Function,\n    method::Function,\n    ref::Vector{Int};\n    ps::AbstractDtry{Float64}=Dtry{Float64}()\n)\n\nPlot the convergence rate of a given integration method mthd for a system sys. SymExpr expr defines a function over the simulation time t. Function error evaluates the results of eqn over a set of time steps hs. ref is the exponent of convergence rates used as references lines. ps overwrites the parameter set of sys.\n\n\n\n\n\n","category":"method"},{"location":"Reference/Simulations/#EPHS.Simulations.plot_evolution-Tuple{SimulationResult, Vararg{Union{SymExpr, Pair{String, <:SymExpr}}}}","page":"Simulations","title":"EPHS.Simulations.plot_evolution","text":"plot_evolution(\n    sim::SimulationResult,\n    exprs_or_pairs::Vararg{Union{SymExpr,Pair{String,<:SymExpr}}}\n)\n\nPlot the time evolution of the given symbolic expressions, which define functions of the state variables. To use a custom label in the legend, supply a Pair{String,SymExpr}. Keyword arguments are passed through to Plots.plot.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#ComponentLibrary","page":"ComponentLibrary","title":"ComponentLibrary","text":"","category":"section"},{"location":"Reference/ComponentLibrary/#StorageComponentLibrary","page":"ComponentLibrary","title":"StorageComponentLibrary","text":"","category":"section"},{"location":"Reference/ComponentLibrary/#ReversibleComponentLibrary","page":"ComponentLibrary","title":"ReversibleComponentLibrary","text":"","category":"section"},{"location":"Reference/ComponentLibrary/#IrreversibleComponentLibrary","page":"ComponentLibrary","title":"IrreversibleComponentLibrary","text":"","category":"section"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary","page":"ComponentLibrary","title":"EPHS.ComponentLibrary","text":"Library of pre-defined components.\n\nThe module is organized into the following submodules: StorageComponentLibrary, ReversibleComponentLibrary, and IrreversibleComponentLibrary.\n\n\n\n\n\n","category":"module"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.StorageComponentLibrary","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.StorageComponentLibrary","text":"Library of pre-defined storage components.\n\n\n\n\n\n","category":"module"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.StorageComponentLibrary.angular_mass-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.StorageComponentLibrary.angular_mass","text":"angular_mass(; m::Float64) -> StorageComponent\n\nCreate an angular mass with default angular mass parameter m. The energy function is given by E(p) = frac12  m  p^2, where p is the angular momentum variable.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.StorageComponentLibrary.hookean_spring-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.StorageComponentLibrary.hookean_spring","text":"hookean_spring(; k::Float64) -> StorageComponent\n\nCreate a Hookean spring with default stiffness parameter k. The energy function is given by E(q) = frac12  k  q^2, where q is the displacement variable.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.StorageComponentLibrary.ideal_gas-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.StorageComponentLibrary.ideal_gas","text":"ideal_gas(; c₁::Float64, c₂::Float64, v₀::Float64, c::Float64) -> StorageComponent\n\nCreate an ideal gas model. The energy function is given by E(s  v) = c_1  exp(fracsc_2)  (fracv_0v)^frac1c, where s is the entropy variable, v is the volume variable, and c_1, c_2, v_0 and c are constitutive parameters.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.StorageComponentLibrary.linear_inductor-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.StorageComponentLibrary.linear_inductor","text":"linear_inductor(; l::Float64) -> StorageComponent\n\nCreate a linear inductor with default inductivity parameter l. The energy function is given by E(b) = frac12  l  b^2, where b is the magnetic flux variable.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.StorageComponentLibrary.point_mass-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.StorageComponentLibrary.point_mass","text":"point_mass(; m::Float64) -> StorageComponent\n\nCreate a point mass with default mass parameter m. The energy function is given by E(p) = frac12  m  p^2, where p is the momentum variable.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.StorageComponentLibrary.thermal_capacity-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.StorageComponentLibrary.thermal_capacity","text":"thermal_capacity(; c₁::Float64, c₂::Float64) -> StorageComponent\n\nCreate a model of a thermal capacity. The energy function is E(s) = c_1  exp(fracsc_2), where s is the entropy variable and c_1 and c_2 are constitutive parameters.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.ReversibleComponentLibrary","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.ReversibleComponentLibrary","text":"Library of pre-defined reverisble components.\n\n\n\n\n\n","category":"module"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.ReversibleComponentLibrary.emc","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.ReversibleComponentLibrary.emc","text":"Electromagnetic coupling: Reversible coupling of an electric energy domain at port mathttq (charge) and a magnetic enregy domain at port mathttb (magnetic flux). The Dirac structure is given by\n\nbeginbmatrix\n  mathttqf \n  mathttbf\nendbmatrix\n = \nbeginbmatrix\n  0  +1 \n  -1  0\nendbmatrix\n\nbeginbmatrix\n  mathttqe \n  mathttbe\nendbmatrix\n\n\n\n\n\n\n","category":"constant"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.ReversibleComponentLibrary.mkc","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.ReversibleComponentLibrary.mkc","text":"Magnetic-kinetic coupling: Reversible coupling of of a magnetic energy domain at port mathttb (magnetic flux) and a kinetic energy domain at port mathttp (angular momentum) based on the Lorentz force. The strength of the coupling is proportional to the magnetic flux at the state port mathttb_s. The Dirac structure is given by\n\nbeginbmatrix\n  mathttbf \n  mathttpf\nendbmatrix\n = \nbeginbmatrix\n  0  +mathttb_sx \n  -mathttb_sx  0\nendbmatrix\n\nbeginbmatrix\n  mathttbe \n  mathttpe\nendbmatrix\n\n\n\n\n\n\n","category":"constant"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.ReversibleComponentLibrary.pkc","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.ReversibleComponentLibrary.pkc","text":"Potential-kinetic coupling: Reversible coupling of a potential energy domain at port mathttq (displacement) and a kinetic enregy domain at port mathttp (momentum). The Dirac structure is given by\n\nbeginbmatrix\n  mathttqf \n  mathttpf\nendbmatrix\n = \nbeginbmatrix\n  0  -1 \n  +1  0\nendbmatrix\n\nbeginbmatrix\n  mathttqe \n  mathttpe\nendbmatrix\n\n\n\n\n\n\n","category":"constant"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.ReversibleComponentLibrary.two_masses_rigid_connection","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.ReversibleComponentLibrary.two_masses_rigid_connection","text":"Dirac structure for a rigid connection of two masses:\n\nbeginbmatrix\n  mathttpf \n  mathttp_2f \n  0\nendbmatrix\n = \nbeginbmatrix\n  0  0  +1 \n  0  0  -1 \n  -1  +1  0\nendbmatrix\n\nbeginbmatrix\n  mathttpe \n  mathttp_2e \n  lambda\nendbmatrix\n\nThe constraint variable lambda distributes the rates of change of the momentum variables mathttpf and mathttp_2f such that the velocities mathttpe and mathttp_2e are equal.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.ReversibleComponentLibrary.two_springs_series_connection","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.ReversibleComponentLibrary.two_springs_series_connection","text":"Dirac structure for connecting two springs in series:\n\nbeginbmatrix\n  mathttqf \n  mathttq_2f \n  0\nendbmatrix\n = \nbeginbmatrix\n  0  0  +1 \n  0  0  -1 \n  -1  +1  0\nendbmatrix\n\nbeginbmatrix\n  mathttqe \n  mathttq_2e \n  lambda\nendbmatrix\n\nThe constraint variable lambda distributes the rates of change of the displacement variables mathttqf and mathttq_2f such that the forces mathttqe and mathttq_2e are equal.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.ReversibleComponentLibrary.hkc-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.ReversibleComponentLibrary.hkc","text":"hkc(; a::Float64) -> ReversibleComponent\n\nHydraulic-kinetic coupling: Create a reversible coupling between the two hydraulic energy domains on either side of a piston (ports mathttv_1 and mathttv_2) and the kinetic energy domain of the piston itself (port mathttp). The Dirac structure is given by\n\nbeginbmatrix\n  mathttpf \n  mathttv_1f \n  mathttv_2f\nendbmatrix\n = \nbeginbmatrix\n  0   +a  -a \n  -a   0   0 \n  +a   0   0 \nendbmatrix\n\nbeginbmatrix\n  mathttpe \n  mathttv_1e \n  mathttv_2e\nendbmatrix\n\n\nwhere the parameter a is the cross-sectional area of the piston.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.ReversibleComponentLibrary.mechanical_lever-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.ReversibleComponentLibrary.mechanical_lever","text":"mechanical_lever(; r::Float64) -> ReversibleComponent\n\nCreate an ideal mechanical lever connecting two potential energy domains via the leverage ratio r. The Dirac structure is given by\n\nbeginbmatrix\n  mathttq_1f \n  mathttq_2e\nendbmatrix\n = \nbeginbmatrix\n  0  -r \n  +r  0\nendbmatrix\n\nbeginbmatrix\n  mathttq_1e \n  mathttq_2f\nendbmatrix\n\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.IrreversibleComponentLibrary","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.IrreversibleComponentLibrary","text":"Library of pre-defined irreverisble components.\n\n\n\n\n\n","category":"module"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.IrreversibleComponentLibrary.heat_transfer-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.IrreversibleComponentLibrary.heat_transfer","text":"heat_transfer(; h::Float64) -> IrreversibleComponent\n\nCreate a linear model of heat transfer with default heat transfer parameter h. The Onsager sturcutre is given by\n\nbeginbmatrix\n  mathtts₁f \n  mathtts₂f\nendbmatrix\n = \nfrac1theta_0\n h \nbeginbmatrix\n  fractheta_2theta_1  -1 \n  -1  fractheta_1theta_2\nendbmatrix\n\nbeginbmatrix\n  mathtts₁e \n  mathtts₂e\nendbmatrix\n = \nbeginbmatrix\n  -frach  (theta_2 - theta_1)theta_1 \n  -frach  (theta_1 - theta_2)theta_2\nendbmatrix\n\n\nwhere theta_1 = theta_0 + mathtts₁e and theta_2 = theta_0 + mathtts₂e represent the absolute temperature of the two thermal energy domains.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.IrreversibleComponentLibrary.linear_friction-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.IrreversibleComponentLibrary.linear_friction","text":"linear_friction(; d::Float64) -> IrreversibleComponent\n\nCreate a linear model of mechanical friction with default friction parameter d. The Onsager structure is given by\n\nbeginbmatrix\n  mathttpf \n  mathttsf\nendbmatrix\n = \nfrac1theta_0  d \nbeginbmatrix\n  theta  -upsilon \n  - upsilon  fracupsilon^2theta\nendbmatrix\n\nbeginbmatrix\n  mathttpe \n  mathttse\nendbmatrix\n = \nbeginbmatrix\n  d  upsilon \n  -fracd  upsilon^2theta\nendbmatrix\n\n\nwhere upsilon = mathttpe is the velocity associated with kinetic energy domain at port mathttp (momentum) and theta = theta_0 + mathttse is the absolute temperature at which kinetic energy is dissipated into the thermal energy domain at port mathtts (entropy).\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.IrreversibleComponentLibrary.magnetic_resistor-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.IrreversibleComponentLibrary.magnetic_resistor","text":"magnetic_resistor(; r::Float64) -> IrreversibleComponent\n\nCreate a model of a linear resistor with default resistance parameter r. The Onsager structure is given by\n\nbeginbmatrix\n  mathttbf \n  mathttsf\nendbmatrix\n = \nfrac1theta_0  r \nbeginbmatrix\n  theta  i \n  -i  fracupsilon^2theta\nendbmatrix\n\nbeginbmatrix\n  mathttbe \n  mathttse\nendbmatrix\n = \nbeginbmatrix\n  r  i \n  -fracr  i^2theta\nendbmatrix\n\n\nwhere i = mathttbe is the current associated with magnetic energy domain at port mathttb (magnetic flux) and theta = theta_0 + mathttse is the absolute temperature at which magnetic energy is dissipated into the thermal energy domain at port mathtts (entropy).\n\n\n\n\n\n","category":"method"},{"location":"Reference/ComponentLibrary/#EPHS.ComponentLibrary.IrreversibleComponentLibrary.rotational_friction-Tuple{}","page":"ComponentLibrary","title":"EPHS.ComponentLibrary.IrreversibleComponentLibrary.rotational_friction","text":"rotational_friction(; d::Float64) -> IrreversibleComponent\n\nCreate a linear model of rotational friction with default friction parameter d. The Onsager structure is given by\n\nbeginbmatrix\n  mathttpf \n  mathttsf\nendbmatrix\n = \nfrac1theta_0  d \nbeginbmatrix\n  theta  upsilon \n  - upsilon  fracupsilon^2theta\nendbmatrix\n\nbeginbmatrix\n  mathttpe \n  mathttse\nendbmatrix\n = \nbeginbmatrix\n  d  upsilon \n  -fracd  upsilon^2theta\nendbmatrix\n\n\nwhere upsilon = mathttpe is the angular velocity associated with kinetic energy domain at port mathttp (momentum) and theta = theta_0 + mathttse is the absolute temperature at which kinetic energy is dissipated into the thermal energy domain at port mathtts (entropy).\n\n\n\n\n\n","category":"method"},{"location":"#Welcome","page":"Home","title":"Welcome","text":"EPHS is a compositional, energy-based (software) framework for modeling mechanical, electromagnetic, and thermodynamic systems.\n\nYou are reading the documentation of a Julia package that implements EPHS as an embedded domain specific modeling language for interconnected/complex physical systems.\n\nThe implementation is based on the theory presented in Exergetic Port-Hamiltonian Systems Modeling Language. Please consult this article for further details and references to other literature.","category":"section"},{"location":"#Outline","page":"Home","title":"Outline","text":"To read about closely related developments and the motivation behind this work, please have a look at the Background section.\nThe Fundamentals section introduces directories, interconnection patterns, and the three kinds of primitive systems.\nTo see the implementation in action, have a look at the Examples section.\nOur vision for the future is summarized on the Vision page.\nThe last section provides a Reference for the Julia codebase.","category":"section"},{"location":"#Contact","page":"Home","title":"Contact","text":"If you are interested in the project, please feel free to get in contact.","category":"section"}]
}
